# Extended Backus–Naur form(EBNF)

> <https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>
>
> <https://en.wikipedia.org/wiki/Formal_language>
>
> <https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols>

## 1. 形式化语言 Formal language

在逻辑、数学、计算机科学和语言学中，形式化语言是由一系列特定单词（words）按照一套特殊规则组成的。这些单词（words）的字母（letters）是来自某一个字母表（alphabet）的，单词必须符合的特定规则称为形式语法（formal grammar）。

形式化语言的字母表是由符号（symbols）、字符（letters）或标记（tokens）组成，它们可以连接成字符串，称为单词（words）。属于某个特定形式语言的单词（words）有时被称为规范良好的单词（well-formed words）或良构公式（well-formed formulas）。通常通过正则文法（regular grammar）或上下文无关文法（context-free grammar）等形式语法（formal grammar）来定义一个形式语言，其包含了该语言的形成规则。

在计算机科学中，形式化语言用于多种用途，例如定义编程语言的语法，以及自然语言子集的形式化版本，其中这些子集中的单词代表与意义相关联的概念。

在逻辑和数学基础领域，形式化语言用于表达公理系统的句法结构，而数学形式主义是一种哲学观点，即所有数学都可以归结为对这种形式化语言进行语法操作。

### 1.1. 终结符 Terminal symbols 和 非终结符 Nonterminal symbols

在形式化语言中，形式化语法（formal grammar）是由产生规则（production rules）构成的，终结符和非终结符是用来指定产生规则的词汇元素。

终结符是形式化语言的基本符号，作为形式化语法的一部分。非终结符（或句法变量）则会根据产生规则被替换为一组终结符。

某个特定语法的终结符和非终结符属于两个完全不同的集合。

#### 1.1.1. 终结符 Terminal symbols

终结符是指在形式文法（formal grammar）的产生规则（production rules）中可能出现的符号，并且不能通过文法规则（rule of grammar）进行变换。对源字符串中的符号递归应用这些规则，通常会最终得到一个只由终结符组成的输出字符串。

考虑由两个规则定义的语法。在这个语法中，符号`Б`是终结符，而`Ψ`既是非终结符也是起始符号。生成字符串的产生规则如下：

1. 符号`Ψ`可以变成`Б` `Ψ`
2. 符号`Ψ`可以变成`Б`

这里，`Б`之所以是终结符，是因为不存在任何规则能将它转换为其他东西。而`Ψ`具有两条可改变它的规则，因此它是非终结符。

由特定语法定义或*生成*的形式化语言，是指那些可以由该语法产生、且*仅包含终结符组成的*字符串集合。

例如根据上面的语法规则，可以生成由任意个`Б`组成的字符串。

#### 1.1.2. 非终结符 Nonterminal symbols

非终结符是指那些可以被替换的符号，它们也可以简单地称为句法变量（syntactic variables）。形式文法包括一个*起始符号*，该符号是非终结符集合中的一个成员，通过连续应用产生规则，可以推导出该语言中的所有字符串。实际上，由某个语法定义的语言，正是能够通过这些规则推导出来的终结符字符串的集合。

无上下文语法（Context-free grammars）是指每条产生规则的左侧仅由单一非终结符组成的语法。这一限制并不容忽视；并不是所有语言都能由上下文无关语法生成。那些能够生成此类语言的，被称为上下文无关语言。这些语言恰好是可以被非确定性*下推自动机*识别的语言。上下文无关语言构成了大多数编程语言语法理论基础。

#### 1.1.3. 产生规则 Production rules

语法由产生规则（或简称“生成式” productions）定义，这些规则指定了哪些符号可以替换其他符号；这些规则既可用于生成字符串，也可用于解析它们。每条规则都有一个*head*，或左侧部分，由可能被替换的字符串组成；以及一个 _body_，或右侧部分，由可能用来替换它的字符串组成。规则通常以 _head -> body_ 的形式书写，例如，_a -> b_ 表示 a 可以被 b 替换。

在诺姆·乔姆斯基层于 1950 年代首次提出的经典形式化生成文法中，一个文法（grammar） $G$ 包含以下组成部分：

-   一个有限集 $N$，包括非终结符符号。
-   一个与 $N$ 不相交的有限集 $Σ$，包括终结符符号。
-   一个有限集 $P$ 的产生规则，每条规则具有如下形式：

    $$
    (\Sigma \cup N)^*\,N\,(\Sigma \cup N)^* \rightarrow (\Sigma \cup N)^*
    $$

    其中，$*$ 是克莱尼星（Kleene star）运算，表示零个或多个符号；$\cup$ 表示取并集，因此 $ (\Sigma \cup N)^* $ 表示零个或多个终结符和非终结符的组合，而 $N$ 表示至少有一个*非终结符\*。这意味着每条产生式从一串包含至少一个非终结符的字符串映射到另一串字符。在 body 仅由空串组成时，可以用特殊记号（常用 $Λ$、$ε$ 或 $e$）表示，以避免混淆。

-   一个特殊标记 $S ∈ N$，被称为起始符。

该文法是由有序四元组 $⟨N, Σ, P, S⟩$ 形式化定义的。此类形式化文法在相关文献中常被称为重写系统（rewriting system）或者短语结构文法（phrase structure grammar）。

#### 1.1.4. 示例

巴克斯-诺尔形式（Backus–Naur form）是一种用于表示某些语法的符号表示法。例如，以下用巴克斯-诺尔形式编写的产生规则，用于表示一个 `integer`（可以带符号）：

```BNF
<digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

<integer> ::= ['-'] <digit> {<digit>}
```

在这个例子中，符号 `（-, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9）` 是终结符，而 `<digit>` 和 `<integer>` 是非终结符。

> 这个例子支持有前导 0 的字符串，例如 "0056" 或 "0000"，也支持负的零字符串，例如 "-0" 或 "-00000"。

另一个例子是：

$$
S ⟶ cAd \\
A ⟶ a|ab
$$

在这个例子中，$a,b,c,d$ 是终结符，而 $S, A$ 是非终结符。

## 2. 扩展巴科斯范式 Extended Backus-Naur form

在计算机科学中，扩展巴科斯范式（EBNF）是一组元语法符号表示法的家族，其中任何一个都可以用来表达上下文无关文法。EBNF 用于对诸如计算机编程语言等正式语言进行形式化描述。它们是对基本巴科斯范式（BNF）元语法符号表示法的扩展。最早的 EBNF 由 Niklaus Wirth 开发，结合了 Wirth 语法符号中的一些概念（但采用了不同的语法和表示法）。如今，许多 EBNF 的变体被广泛使用。国际标准化组织于 1996 年采纳了 EBNF 标准，即 ISO/IEC 14977。

然而，根据 Zaytsev 的说法，这一标准“只是在混乱中又增加了三种方言”，并在指出其缺乏成功后，还提到 ISO EBNF 并未在所有 ISO 标准中使用。

Wheeler 反对在使用 EBNF 时采用 ISO 标准，并建议考虑其他 EBNF 表示法，例如来自 W3C 可扩展标记语言（XML）1.0（第五版）的表示法。

本文使用 ISO 指定的 EBNF 作为适用于所有 EBNF 的示例。其他 EBNF 变体使用略有不同的语法约定。

### 2.1. 基础

EBNF 是一种表达形式化语言语法的代码。 EBNF 由终结符 (terminal symbols) 和非终结的产生规则 (non-terminal production rules) 组成，这些规则规定了终结符如何组合成有效的序列。终结符的例子包括字母数字字符、标点符号和空白字符。

EBNF 定义了产生规则 (production rules)，其中符号序列分别被分配给一个非终结符(nonterminal)：

```EBNF
digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
digit                = "0" | digit excluding zero ;
```

此产生规则定义了非终结符 `digit`，它位于赋值符号的左侧。竖线表示“或”，终结符用引号括起来，并以分号作为终止字符。因此，`digit` 是 `0` 或 `digit excluding zero`，可以是 `1` 或 `2` 或 `3`，以此类推，直到 `9`。

产生规则还可以包含终结符或非终结符的序列，每个符号之间用逗号分隔：

```EBNF
twelve                          = "1", "2" ;
two hundred one                 = "2", "0", "1" ;
three hundred twelve            = "3", twelve ;
twelve thousand two hundred one = twelve, two hundred one ;
```

可以通过大括号 `{ ... }` 表示可以省略或重复的表达式：

```EBNF
positive integer = digit excluding zero, { digit } ;
```

在这种情况下，字符串 `1`, `2`, ..., `10`, ..., `10000`, ... 是正确的表达式。为了表示这一点，大括号内的所有内容可以重复任意多次，包括一次都不重复。

选项可以通过方括号 `[ ... ]` 表示。也就是说，方括号内的内容可以出现一次，或者完全不出现：

```EBNF
integer = "0" | [ "-" ], positive integer ;
```

因此，`integer` 是 `0` 或 可能前面带有一个可选的负号的正整数。

EBNF 还提供了其他功能，例如描述重复（指定次数）、排除生产规则的一部分，以及在 EBNF 文法中插入注释的语法。

#### 2.1.1. 符号表

以下内容是由 R. S. Scowen 在第 7 页的表格 1 和 2 中提出的 ISO/IEC 14977 标准建议。

| 用法                       | 符号        | 替代符号    | 含义     |
| -------------------------- | ----------- | ----------- | -------- |
| 定义 definition            | `=`         |             |          |
| 串联 concatenation         | `,`         |             |          |
| 结束符 termination         | `;`         | `.`         |          |
| 选择 alternation           | `\|`        | `/` 或 `!`  |          |
| 可选项 optional            | `[ ... ]`   | `(/ ... /)` | 无或一次 |
| 重复 repetition            | `{ ... }`   | `(: ... :)` | 无或多次 |
| 分组 grouping              | `( ... )`   |             |          |
| 终结字符串 terminal string | `" ... "`   | `' ... '`   |          |
| 注释 comment               | `(* ... *)` |             |          |
| 特殊序列 special sequence  | `? ... ?`   |             |          |
| 例外 exception             | `-`         |             |          |
