# 面向对象六大原则：

- **开闭原则**：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。
- **单一职责原则**：一个类只做一件事，一个类应该只有一个引起它修改的原因。
- **里氏替换原则**：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。
- **依赖倒置原则**：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
- **迪米特法则**：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。
- **接口隔离原则**：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。
- 合成 / 聚合复用原则：优先使用合成 / 聚合，而不是类继承。（并非六大原则）

# 1 工厂模式

当使用一个类Product的时候，让调用者和Product的耦合变松，无需知道如何创建Product的细节。

## 1.1 简单工厂

工厂类：

```java
public class FruitFactory {
    public Fruit create(String type){
        switch (type){
            case "苹果": return new Apple();	// 可能会很复杂
            case "梨子": return new Pear();
            default: throw new IllegalArgumentException("暂时没有这种水果");
        }
    }
}
```

调用者：

```java
public class User {
    private void eat(){
        FruitFactory fruitFactory = new FruitFactory();
        Fruit apple = fruitFactory.create("苹果");
        Fruit pear = fruitFactory.create("梨子");
        apple.eat();
        pear.eat();
    }
}
```

简单工厂在GoF的设计模式中，仅仅是工厂模式的特例。

优点：

1. 降低了调用者和Apple、Pear的耦合。
2. 隐藏了创建Apple的细节。客户端对此无需关心。

缺点：

1. 随着产品的增多，工厂会过于庞大。同时任意产品生产过程需要修改时，均需要修改工程类。有多个引起修改的原因，违背了单一职责。
2. 新增产品需要修改switch，添加新的分支。违背了开闭原则。

![image-20230613144349306](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-202306131443493064x4cV3.png)

## 1.2 工厂方法模式

针对不同的产品有不同的工厂，这些工厂也可以实现一个共同的抽象接口。

苹果工厂：

```java
public class AppleFactory {
    public Fruit create(){
        return new Apple();
    }
}
```

梨子工厂：

```java
public class PearFactory {
    public Fruit create(){
        return new Pear();
    }
}
```

调用者：

```java
public class User {
    private void eat(){
        AppleFactory appleFactory = new AppleFactory();
        Fruit apple = appleFactory.create();
        PearFactory pearFactory = new PearFactory();
        Fruit pear = pearFactory.create();
        apple.eat();
        pear.eat();
    }
}
```

优点：

1. 降低了调用者与Apple、Pear的耦合，隐去了产品生产的细节。
2. 产品增多时，不会像简单工程一样使工厂类非常大，修改某一个产品的生产方法时，只需要修改对应的工厂类，符合单一职责。
3. 增加新产品只需要添加新工厂，符合开闭原则。

![image-20230613144402348](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144402348zveOf8.png)

## 2 抽象工厂模式

工厂类实现一个共同的抽象接口，这样就可以便利地替换工厂实现，从而替换一系列的工厂方法。

同时抽象工厂还可能面对多个产品，如工厂不止生产水果，还生产不同的洗衣机等，在工厂1内就可能生成水果1、洗衣机1；工厂2生成水果2、洗衣机2。

抽象工厂方法最典型的应用在于：连接不同数据库时，屏蔽数据库底层细节。

数据库1（苹果数据库）对应的工厂：

```java
public class AppleFactory implements IFactory {
    @Override
    public Fruit create(){
        return new Apple();
    }
  
    @Override
    public int update(){
        // ...
    }
}
```

调用者

```java
public class User {
    private void eat(){
        IFactory appleFactory = new AppleFactory();
        Fruit apple = appleFactory.create();
        int res = appleFactory.update();
        apple.eat();
    }
}
```

只需要修改IFactory的实现类，就可以轻松切换一系列的方法。

优点：

1. 符合开闭原则、依赖倒置，可以非常方便地替换一系列方法。

缺点：

1. 如果工厂接口需要新增功能，就会影响所有的具体工厂类。

所以抽象工厂模式适用于可能会新增同类工厂这样的横向扩展需求，不适合可能会新增功能这样的纵向拓展。

![image-20230613144433227](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-202306131444332273ke1dr.png)

## HeadFirst对工厂模式的描述

### 工厂方法

![image-20230722150944052](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230722150944052XeBdqI.png)

有一个披萨店`PizzaStore`，客户可以订购披萨，所以提供一个`orderPizza()`方法。订披萨的话需要制作一个披萨。

```java
public PizzaStore {
  
  public void orderPizza() {
    Pizza pizza = createPizza();
    bake();
    // ...
  }
  
  abstract Pizza createPizza();
  
}
```

`createPizza()`方法是抽象方法，在子类里实现，这样就把对象的创建委托给了子类。

```java
public BeijingPizzaStore extends PizzaStore {
  public Pizza createPizza() {
    // 制作北京的菠萝披萨（意大利店就没有）
    return new PineapplePizza();
  }
}
```

这样`PizzaStore`就和具体的`PineapplePizza`进行了解耦，只针对接口`Pizza`编程。

### 依赖倒置

如果是`PizzaStore`直接创建各种具体披萨，这里原来的依赖关系就是，`PizzaStore`依赖了各种具体披萨。

现在是`PizzaStore`依赖`Pizza`，然后各个具体类依赖`Pizza`。依赖关系就倒过来了。

依赖：A依赖B，即B的修改一定会导致A的修改。

![image-20230722151734044](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230722151734044mDPh9y.png)

![image-20230722151742193](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230722151742193269q08.png)

原来的思考方式：

1. 我要开一个披萨店，有一个`PizzaStore`
2. 要卖各种披萨，所以披萨店可以创建各类披萨

倒置后：

1. 由于各个类都是披萨，要有一个`Pizza`类。
2. 所以需要一个工厂来提供各个披萨。
3. 这样具体披萨依赖于抽象类，披萨店也依赖于抽象类。

### 抽象工厂

如果我需要一系列产品，比如说一系列披萨的原料。

那么就在创建披萨的时候传入原料工厂（在`createPizza`的时候），然后委托给原料工厂生产一系列的原料。

# 3 单例模式

## 饿汉

```java
public class Singleton {
  
    private static Singleton instance = new Singleton();

    private Singleton() {	// 声明private的空参构造方法，这样编译器就不会添加默认的public空参构造方法
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

缺点：单例不需要使用的时候也会在类加载的时候立即创建。

## 懒汉1：双检锁

```java
public class Singleton {
  
    private static Singleton instance = null;
  
    private Singleton() { // 声明private的空参构造方法，这样编译器就不会添加默认的public空参构造方法
    }
    
    public static Singleton getInstance(){
 				if (instance == null) {	// 保证效率
            synchronized (Singleton.class) {	// 线程安全
                if (instance == null) {	// 线程安全
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 懒汉2：静态内部类

```java
public class Singleton {
    
    private static class SingletonHolder {
        public static Singleton instance = new Singleton();
    }

    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```

1. 静态内部类是懒加载，在使用时才会初始化，所以是懒汉式。
2. JVM会保证静态内部类的静态字段初始化的线程安全。

缺点：

1. 使用时才会加载，可能会影响用户体验。
2. Martin《代码整洁之道》一书中也说到：不提倡使用懒加载方式，因为程序应该将构建与使用分离，达到解耦。饿汉式在声明时直接初始化变量的方式也更直观易懂。

![image-20230613144508938](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144508938IrSaDK.png)

# 4 建造者模式

建造者模式用于创建过程稳定，但配置多变的对象。在《设计模式》一书中的定义是：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。**

原书中的是「建造者-指挥者」模式，现在已经不太常用了。是由一个builder声明一系列的build方法（set方法），然后由一个director来编写需要用到哪些build方法。

现在建造者模式主要用来通过链式调用生成不同的配置。使用建造者模式的好处是不用担心忘了指定某个配置，保证了构建过程是稳定的。

例如制作奶茶，除了种类、规格外，可以选择是否加珍珠和加冰。

```java
public class MilkTeaBuilder {

  private final String type;
  private final String size;
  private final boolean pearl;
  private final boolean ice;

  MilkTeaBuilder(String type, String size) {
    this.type = type;
    this.size = size;
    this.pearl = false;
    this.ice = false;
  }

  MilkTeaBuilder setPearl(boolean pearl) {
    this.pearl = pearl;
    return this;
  }

  MilkTeaBuilder setPearl(boolean ice) {
    this.ice = ice;
    return this;
  }

  public MilkTea build() {
    return new MilkTea(type, size, pearl, ice);
  }
}
```

调用者

```java
public class User {
    public void buyMilkTea() {
        MilkTea milkTea = MilkTeaBuilder("原味", "大杯").build();

        MilkTea chocolate = MilkTeaBuilder("巧克力味", "中杯")
                .ice(false)
                .build();
    }
}
```

使用建造者模式的好处是不用担心忘了指定某个配置，保证了构建过程是稳定的。

![image-20230613144558864](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144558864s29kK3.png)

# 5 原型模式

为了实现对某个对象的拷贝。Java中可以实现Cloneable接口，不过注意Java自带的clone是浅拷贝，只会拷贝基本类型，想要实现深拷贝需要自己实现。

```java
public class MilkTea implements Cloneable {
    public String type;
    public boolean ice;

    @NonNull
    @Override
    protected MilkTea clone() throws CloneNotSupportedException {
        return (MilkTea) super.clone();
    }
}
```

![image-20230613144531862](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144531862FyVLG7.png)

# 6 适配器模式

适配器模式并不推荐，能事先预防接口不同的问题最好。

只有遇到源接口无法改变时，才考虑使用。

![image-20230613144636787](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144636787huJcCl.png)

# 7 桥接模式

将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。它主要用于 **两个或多个同等级的接口**。

通俗地说，如果一个对象有两种或者多种分类方式，并且两种分类方式都容易变化，这时使用继承很容易造成子类越来越多，所以更好的做法是把这种分类方式分离出来，让他们独立变化，使用时将不同的分类进行组合即可。

比如现在玩具有2种形状，三角形和正方形。同时还有红黄蓝3种颜色。那么可以将颜色接口作为形状类的一个字段。

![image-20230613144925590](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613144925590uLeEIV.png)

# 8 组合模式

又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

比如说一个公司里的领导和员工，有很多通用的属性、方法，那么就可以继承自同一个抽象类，然后各自实现不同的方法。在使用的时候，可以直接用抽象类接受并调用。

## 8.1 透明方式

树状结构需要add和remove节点，而叶子节点不应该有这2个方法。这里违反了接口隔离原则，不够安全。好处是调用者可以一致调用。

## 8.2 安全方式

让add和move方法只作为Composite的方法。在叶子节点里没有这2个方法。但是使用时要区别对待叶子节点和枝节点，会不太方便。

![image-20230613145251544](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613145251544Gx2OsL.png)

# 9 装饰模式

动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。

主要功能：

- **增强一个类原有的功能**
- **为一个类添加新的功能**

装饰模式也不会改变原有的类。



![image-20230613150618836](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613150618836OykNUa.png)

## 9.1 用于增强功能的装饰模式

我们用程序来模拟一下戴上装饰品提高我们颜值的过程：

新建颜值接口：

```java
public interface IBeauty {
    int getBeautyValue();
}
```

新建 Me 类，实现颜值接口：

```java
public class Me implements IBeauty {

    @Override
    public int getBeautyValue() {
        return 100;
    }
}
```

戒指装饰类，将 Me 包装起来：

```java
public class RingDecorator implements IBeauty {
    private final IBeauty me;

    public RingDecorator(IBeauty me) {
        this.me = me;
    }

    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 20;
    }
}
```

客户端测试：

```java
public class Client {
    @Test
    public void show() {
        IBeauty me = new Me();
        System.out.println("我原本的颜值：" + me.getBeautyValue());

        IBeauty meWithRing = new RingDecorator(me);
        System.out.println("戴上了戒指后，我的颜值：" + meWithRing.getBeautyValue());
    }
}
```

运行程序，输出如下：

```text
我原本的颜值：100
戴上了戒指后，我的颜值：120
```

这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：

耳环装饰类：

```java
public class EarringDecorator implements IBeauty {
    private final IBeauty me;

    public EarringDecorator(IBeauty me) {
        this.me = me;
    }

    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 50;
    }
}
```

项链装饰类：

```java
public class NecklaceDecorator implements IBeauty {
    private final IBeauty me;

    public NecklaceDecorator(IBeauty me) {
        this.me = me;
    }

    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 80;
    }
}
```

客户端测试：

```java
public class Client {
    @Test
    public void show() {
        IBeauty me = new Me();
        System.out.println("我原本的颜值：" + me.getBeautyValue());

        // 随意挑选装饰
        IBeauty meWithNecklace = new NecklaceDecorator(me);
        System.out.println("戴上了项链后，我的颜值：" + meWithNecklace.getBeautyValue());

        // 多次装饰
        IBeauty meWithManyDecorators = new NecklaceDecorator(new RingDecorator(new EarringDecorator(me)));
        System.out.println("戴上耳环、戒指、项链后，我的颜值：" + meWithManyDecorators.getBeautyValue());

        // 任意搭配装饰
        IBeauty meWithNecklaceAndRing = new NecklaceDecorator(new RingDecorator(me));
        System.out.println("戴上戒指、项链后，我的颜值：" + meWithNecklaceAndRing.getBeautyValue());
    }
}
```

运行程序，输出如下：

```text
我原本的颜值：100
戴上了项链后，我的颜值：180
戴上耳环、戒指、项链后，我的颜值：250
戴上戒指、项链后，我的颜值：200
```

可以看到，装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器**仅用于增强功能**，**并不会改变 Me 原有的功能**，这种装饰模式称之为 **透明装饰模式**，由于没有改变接口，也没有新增方法，所以**透明装饰模式可以无限装饰**。

装饰模式是 **继承** 的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类......各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就 **增加对象功能** 来说，**装饰模式比生成子类实现更为灵活**。

## 9.2 用于添加功能的装饰模式

我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：

新建房屋接口：

```java
public interface IHouse {
    void live();
}
```

房屋类：

```java
public class House implements IHouse{

    @Override
    public void live() {
        System.out.println("房屋原有的功能：居住功能");
    }
}
```

新建粘钩装饰器接口，继承自房屋接口：

```java
public interface IStickyHookHouse extends IHouse{
    void hangThings();
}
```

粘钩装饰类：

```java
public class StickyHookDecorator implements IStickyHookHouse {
    private final IHouse house;

    public StickyHookDecorator(IHouse house) {
        this.house = house;
    }

    @Override
    public void live() {
        house.live();
    }

    @Override
    public void hangThings() {
        System.out.println("有了粘钩后，新增了挂东西功能");
    }
}
```

客户端测试：

```java
public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();

        IStickyHookHouse stickyHookHouse = new StickyHookDecorator(house);
        stickyHookHouse.live();
        stickyHookHouse.hangThings();
    }
}
```

运行程序，显示如下：

```text
房屋原有的功能：居住功能
房屋原有的功能：居住功能
有了粘钩后，新增了挂东西功能
```

这就是用于 **新增功能** 的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为 **半透明装饰模式**。

为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待 **装饰前的对象和装饰后的对象**。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。

我们可以添加更多的装饰器：

新建镜子装饰器的接口，继承自房屋接口：

```java
public interface IMirrorHouse extends IHouse {
    void lookMirror();
}
```

镜子装饰类：

```java
public class MirrorDecorator implements IMirrorHouse{
    private final IHouse house;

    public MirrorDecorator(IHouse house) {
        this.house = house;
    }

    @Override
    public void live() {
        house.live();
    }

    @Override
    public void lookMirror() {
        System.out.println("有了镜子后，新增了照镜子功能");
    }
}
```

客户端测试：

```java
public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();

        IMirrorHouse mirrorHouse = new MirrorDecorator(house);
        mirrorHouse.live();
        mirrorHouse.lookMirror();
    }
}
```

运行程序，输出如下：

```text
房屋原有的功能：居住功能
房屋原有的功能：居住功能
有了镜子后，新增了照镜子功能
```

现在我们仿照 **透明装饰模式** 的写法，同时添加粘钩和镜子装饰试一试：

```java
public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();

        IStickyHookHouse stickyHookHouse = new StickyHookDecorator(house);
        IMirrorHouse houseWithStickyHookMirror = new MirrorDecorator(stickyHookHouse);
        houseWithStickyHookMirror.live();
        houseWithStickyHookMirror.hangThings(); // 这里会报错，找不到 hangThings 方法
        houseWithStickyHookMirror.lookMirror();
    }
}
```

我们会发现，第二次装饰时，无法获得上一次装饰添加的方法。原因很明显，当我们用 IMirrorHouse 装饰器后，接口变为了 IMirrorHouse，这个接口中并没有 hangThings 方法。

那么我们能否让 IMirrorHouse 继承自 IStickyHookHouse，以实现新增两个功能呢？

可以，但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了。装饰类不应该存在依赖关系，而应该在原本的类上进行装饰。这就意味着，**半透明装饰模式中**，**我们无法多次装饰**。



有的同学会问了，既增强了功能，又添加了新功能的装饰模式叫什么呢？

—— 举一反三，肯定是叫全不透明装饰模式！

—— 并不是！只要添加了新功能的装饰模式都称之为 **半透明装饰模式**，他们都具有不可以多次装饰的特点。仔细理解上文半透明名称的由来就知道了，“透明”指的是我们无需知道被装饰者具体的类，既增强了功能，又添加了新功能的装饰模式仍然具有半透明特性。

## 9.3 I/O中的装饰模式

I/O 指的是 Input/Output，即输入、输出。我们以 Input 为例。先在 `src` 文件夹下新建一个文件 readme.text。

然后读取文件内容:

```java
public void io() throws IOException {
    try (InputStream in = new BufferedInputStream(new FileInputStream("src/readme.txt"))) {
        byte[] buffer = new byte[1024];
        while (in.read(buffer) != -1) {
            System.out.println(new String(buffer));
        }
    }
}
```

注意到`InputStream in = new BufferedInputStream(new FileInputStream("src/readme.txt"))`实际上就是装饰模式

![img](https://gitee.com/chLemon/pictures/raw/master/Picsee/v2-b02e80f8c9e31c309cfa41ba191a0919_1440w0ugtIP.png)

上图中，左边的三个类 FileInputStream、ByteArrayInputStream、ServletInputStream 是 InputStream 的三个子类，对应上文例子中实现了 IHouse 接口的 House。

右下角的三个类 BufferedInputStream、DataInputStream、CheckedInputStream 是三个具体的装饰者类，他们都为 InputStream 增强了原有功能或添加了新功能。

FilterInputStream 是所有装饰类的父类，它没有实现具体的功能，仅用来包装了一下 InputStream。

我们以 BufferedInputStream 为例。原有的 InputStream 读取文件时，是一个字节一个字节读取的，这种方式的执行效率并不高，所以我们可以设立一个缓冲区，先将内容读取到缓冲区中，缓冲区读满后，将内容从缓冲区中取出来，这样就变成了一段一段读取，用内存换取效率。BufferedInputStream 就是用来做这个的。它继承自 FilterInputStream。

在源码中我们发现，BufferedInputStream 没有添加 InputStream 中没有的方法，所以 BufferedInputStream 使用的是 **透明的装饰模式**。

DataInputStream 用于更加方便地读取 int、double 等内容，观察 DataInputStream 的源码可以发现，DataInputStream 中新增了 readInt、readLong 等方法，所以 DataInputStream 使用的是 **半透明装饰模式**。



这就是装饰模式，注意不要和适配器模式混淆了。两者在使用时都是包装一个类，但两者的区别其实也很明显：

- 纯粹的适配器模式 **仅用于改变接口**，不改变其功能，部分情况下我们需要改变一点功能以适配新接口。但使用适配器模式时，接口一定会有一个 **回炉重造** 的过程。
- 装饰模式 **不改变原有的接口**，仅用于增强原有功能或添加新功能，强调的是 **锦上添花**。

掌握了装饰者模式之后，理解 Java I/O 的框架设计就非常容易了。但对于不理解装饰模式的人来说，各种各样相似的 InputStream 非常容易让开发者感到困惑。这一点正是装饰模式的缺点：**容易造成程序中有大量相似的类**。虽然这更像是开发者的缺点，我们应该做的是提高自己的技术，掌握了这个设计模式之后它就是我们的一把利器。现在我们再看到 I/O 不同的 InputStream 装饰类，只需要关注它增强了什么功能或添加了什么功能即可。

# 10 外观模式

将一些借口进行封装，通过外观类简介交互，只暴露简洁的接口。

![image-20230613153528083](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613153528083Gvsd4L.png)

# 11 享元模式

享元模式体现的是 **程序可复用** 的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don't repeat yourself. 简单来说 **享元模式就是共享对象**，提高复用性，官方的定义倒是显得文绉绉的：

> **享元模式**：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。

有个细节值得注意：有些对象本身不一样，但通过一点点变化后就可以复用，我们编程时可能稍不注意就会忘记复用这些对象。比如说伟大的《超级玛丽》，谁能想到草和云更改一下颜色就可以实现复用呢？

还有里面的三种乌龟，换一个颜色、加一个装饰就变成了不同的怪。

![img](https://gitee.com/chLemon/pictures/raw/master/Picsee/v2-751d3caaf8f304bd67097a4d5a7888ce_1440wbmRg6m.png)

![image-20230613153501277](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613153501277Fttd85.png)

# 12 代理模式

用代理将实体类包一层，客户端直接调用代理类，代理类调用实体类。通常可以用来**打印日志、权限管理**。这个代理类看起来和装饰模式一模一样，但两者的目的不同，装饰模式是为了 **增强功能或添加功能**，代理模式主要是为了**加以控制**。

![image-20230613153747029](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613153747029yPDnnk.png)

## 12.1 静态代理

上述这种方法叫静态代理，在Proxy里需要将RealSubject的方法一一实现。

## 12.2 动态代理

将实体类传入代理类，每当实体类被调用时，可以选择性的根据调用的方法加以控制。

在Java中是用反射实现的。

```java
public class HttpProxy implements InvocationHandler {
    private HttpUtil httpUtil;

    public IHttp getInstance(HttpUtil httpUtil) {
        this.httpUtil = httpUtil;
        return (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces(), this);
    }

    // 调用 httpUtil 的任意方法时，都要通过这个方法调用
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = null;
        if (method.getName().equals("request")) {
            // 如果方法名是 request，打印日志，并调用 request 方法
            System.out.println("发送数据:" + args[0]);
            result = method.invoke(httpUtil, args);
        } else if (method.getName().equals("onSuccess")) {
            // 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法
            System.out.println("收到数据:" + args[0]);
            result = method.invoke(httpUtil, args);
        }
        return result;
    }
}
```

先看 getInstance 方法，Proxy.newProxyInstance 方法是 Java 系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的 ClassLoader，第二个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的目的：**调用被代理类的任意方法时**，**都通过一个方法间接调用**。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个目的。

第三个参数是 InvocationHandler 接口，这个接口中只有一个方法：

```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
```

那么不用猜就知道，现在我们调用被代理类 httpUtil 的任意方法时，都会通过这个 invoke 方法调用了。invoke 方法中，第一个参数我们暂时用不上，第二个参数 method 就是调用的方法，使用 method.getName() 可以获取到方法名，第三个参数是调用 method 方法需要传入的参数。本例中无论 request 还是 onSuccess 都只有一个 String 类型的参数，对应到这里就是 args[0]。返回的 Object 是 method 方法的返回值，本例中都是无返回值的。

我们在 invoke 方法中判断了当前调用方法的方法名，如果现在调用的方法是 request，那么打印请求参数，并使用这一行代码继续执行当前方法：

```java
result = method.invoke(httpUtil, args);
```

虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。

动态代理本质上与静态代理没有区别，它的好处是 **节省代码量**。比如被代理类有 20 个方法，而我们只需要控制其中的两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就需要将另外的 18 个方法也写出来，非常繁琐。这就是动态代理的优势所在。

# 13 责任链模式

责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

责任链主要用于处理**职责相同，程度不同的类**。

其主要优点有：

- 降低了对象之间的耦合度。在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。
- 扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。
- 灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。
- 简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的条件判断语句。
- 责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。不再需要 “项目经理” 来处理所有的责任分配任务。

其主要缺点有：

- 不能保证每个请求一定被处理，该请求可能一直传到链的末端都得不到处理。
- 如果责任链过长，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
- 责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链拼接次序错误而导致系统出错，比如可能出现循环调用。

![image-20230613160008444](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-202306131600084446nZKx9.png)

# 14 命令模式

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

可以将 “行为请求者” 和 ”行为实现者“ 解耦。

例如：

开门命令，省略其他

```java
public class DoorOpenCommand implements ICommand {
    private Door door;

    public void setDoor(Door door) {
        this.door = door;
    }

    @Override
    public void execute() {
        door.openDoor();
    }

    @Override
    public void undo() {
        door.closeDoor();
    }
}
```

调用者：

```java
public class Client {

    // 所有的命令
    Stack<ICommand> commands = new Stack<>();

    @Test
    protected void test() {
        ...初始化

        // 大门开关遥控
        switchDoor.setOnCheckedChangeListener((view, isChecked) -> {
            handleCommand(isChecked, doorOpenCommand, doorCloseCommand);
        });
        // 电灯开关遥控
        switchLight.setOnCheckedChangeListener((view, isChecked) -> {
            handleCommand(isChecked, lightOnCommand, lightOffCommand);
        });
        // 电视开关遥控
        switchTv.setOnCheckedChangeListener((view, isChecked) -> {
            handleCommand(isChecked, turnOnTvCommand, turnOffTvCommand);
        });
        // 音乐开关遥控
        switchMusic.setOnCheckedChangeListener((view, isChecked) -> {
            handleCommand(isChecked, musicPlayCommand, musicStopCommand);
        });

        // 撤销按钮
        btnUndo.setOnClickListener(view -> {
            if (commands.isEmpty()) return;
            // 撤销上一个命令
            ICommand lastCommand = commands.pop();
            lastCommand.undo();
        });
    }

    private void handleCommand(boolean isChecked, ICommand openCommand, ICommand closeCommand) {
        if (isChecked) {
            commands.push(openCommand);
            openCommand.execute();
        } else {
            commands.push(closeCommand);
            closeCommand.execute();
        }
    }
}
```

命令模式使得客户端的职责更加简洁、清晰了，命令执行、撤销的代码都被隐藏到了命令类中。唯一的缺点是多了很多的命令类，因为我们必须针对每一个命令都设计一个命令类，容易导致类爆炸。

![image-20230613161547396](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230613161547396Mjavpd.png)

## **小结**

前文的定义中讲到，命令模式还可以用于请求排队。要实现请求排队功能，只需创建一个命令队列，将每个需要执行的命令依次传入队列中，然后工作线程不断地从命令队列取出队列头的命令执行即可。

事实上，安卓 app 的界面就是这么实现的。源码中使用了一个阻塞式死循环 Looper，不断地从 MessageQueue 中取出消息，交给 Handler 处理，用户的每一个操作也会通过 Handler 传递到 MessageQueue 中排队执行。

命令模式可以说将封装发挥得淋漓尽致。在我们平时的程序设计中，最常用的封装是将拥有一类职责的对象封装成类，而命令对象的唯一职责就是通过 execute 去调用一个方法，也就是说它将 “方法调用” 这个步骤封装起来了，使得我们可以对 “方法调用” 进行排队、撤销等处理。

命令模式的主要优点如下：

- 降低系统的耦合度。将 “行为请求者” 和 ”行为实现者“ 解耦。
- 扩展性强。增加或删除命令非常方便，并且不会影响其他类。
- 封装 “方法调用”，方便实现 Undo 和 Redo 操作。
- 灵活性强，可以实现宏命令。

它的主要缺点是：

- 会产生大量命令类。增加了系统的复杂性。

# 15 解释器模式

解释器模式（Interpreter Pattern）：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

在解释器模式中，我们将不可拆分的最小单元称之为终结表达式，可以被拆分的表达式称之为非终结表达式。

解释器模式具有一定的拓展性，当需要添加其他计算符时，我们可以通过添加 Operator 的子类来完成。但添加后需要按照运算优先级修改计算规则。可见一个完整的解释器模式是非常复杂的，实际开发中几乎没有需要自定义解释器的情况。

解释器模式有一个常见的应用，在我们平时匹配字符串时，用到的正则表达式就是一个解释器。正则表达式中，表示一个字符的表达式属于终结表达式，除终结表达式外的所有表达式都属于非终结表达式。

![image-20230614163601024](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614163601024AJkjRw.png)

# 16 迭代器模式

> 迭代器模式（Iterator Pattern）：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。

迭代器模式的核心就在于定义出 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的。

我们平时常用的 for-each 循环，也是迭代器模式的一种应用。在 Java 中，只要实现了 Iterable 接口的类，都被视为可迭代访问的。Iterable 中的核心方法只有一个 用于获取迭代器的 iterator() 方法。

# 17 中介者模式

> 中介者模式（Mediator Pattern）：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。

中介者模式的缺点也很明显：由于它将所有的职责都移到了中介者类中，也就是说中介类需要处理所有类之间的协调工作，这可能会使中介者演变成一个超级类。所以使用中介者模式时需要权衡利弊。

![image-20230614163943461](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614163943461OhDYrk.png)

# 18 备忘录模式

> 备忘录模式：在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态。

备忘录模式的优点是：

- 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态
- 实现了信息的封装，使得用户不需要关心状态的保存细节

缺点是：

- 消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

总体而言，备忘录模式是利大于弊的，所以许多程序都为用户提供了备份方案。比如 IDE 中，用户可以将自己的设置导出成 zip，当需要恢复设置时，再将导出的 zip 文件导入即可。这个功能内部的原理就是备忘录模式。

![image-20230614164316522](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614164316522BY09hJ.png)

# 19 观察者模式

观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

也叫 发布-订阅 模式。

实际上，Java 已经为我们提供了的 Observable 类和 Observer 类，我们在用到观察者模式时，无需自己创建这两个基类，我们来看一下 Java 中提供的源码：

java.util.Observer 类：

```java
public interface Observer {
    void update(Observable o, Object arg);
}
```

Observer 类和我们上例中的定义基本一致，都是只有一个 update 方法用于响应 Observable 的事件。区别有两点：

- update 方法将 Observable 对象也提供给了 Observer
- update 方法中的参数类型变成了 Object

这两点区别都是为了保证此 Observer 的适用范围更广。

![image-20230614164519277](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614164519277ApJasL.png)

# 20 状态模式

状态模式（State Pattern）：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。



通俗地说，状态模式就是一个关于多态的设计模式。

如果一个对象有多种状态，并且每种状态下的行为不同，一般的做法是在这个对象的各个行为中添加 if-else 或者 switch-case 语句。但更好的做法是为每种状态创建一个状态对象，使用状态对象替换掉这些条件判断语句，使得状态控制更加灵活，扩展性也更好。

举个例子，力扣的用户有两种状态：普通用户和 PLUS 会员。PLUS 会员有非常多的专享功能，其中“模拟面试”功能非常有特色，我们便以此为例。

- 当普通用户点击模拟面试功能时，提示用户：模拟面试是 Plus 会员专享功能；
- 当 PLUS 会员点击模拟面试功能时，开始一场模拟面试。

先来看看不使用状态模式的写法，看出它的缺点后，我们再用状态模式来重构代码。

首先定义一个用户状态枚举类：

```java
public enum State {
    NORMAL, PLUS
}
```

NORMAL 代表普通用户状态，PLUS 代表 PLUS 会员状态。

用户的功能接口：

```java
public interface IUser {
    void mockInterview();
}
```

本例中我们只定义了一个模拟面试的方法，实际开发中这里可能会有许许多多的方法。

用户状态切换接口：

```java
public interface ISwitchState {
    void purchasePlus();

    void expire();
}
```

此接口中定义了两个方法：purchasePlus 方法表示购买 Plus 会员，用户状态变为 PLUS 会员状态，expire 方法表示会员过期，用户状态变为普通用户状态。

力扣用户类：

```java
public class User implements IUser, ISwitchState {
    private State state = State.NORMAL;

    @Override
    public void mockInterview() {
        if (state == State.PLUS) {
            System.out.println("开始模拟面试");
        } else {
            System.out.println("模拟面试是 Plus 会员专享功能");
        }
    }

    @Override
    public void purchasePlus() {
        state = State.PLUS;
    }

    @Override
    public void expire() {
        state = State.NORMAL;
    }
}
```

用户类实现了 IUser 接口，IUser 接口中的每个功能都需要判断用户是否为 Plus 会员，也就是说每个方法中都有 if (state == State.PLUS) {} else {} 语句，如果状态不止两种，还需要用上 switch-case 语句来判断状态，这就是不使用状态模式的弊端：

- 判断用户状态会产生大量的分支判断语句，导致代码冗长；
- 当状态有增加或减少时，需要改动多个地方，违反开闭原则。

在《代码整洁之道》、《重构》两本书中都提到：应使用多态取代条件表达式。接下来我们就利用多态特性重构这份代码。为每个状态新建一个状态类，普通用户：

```java
class Normal implements IUser {

    @Override
    public void mockInterview() {
        System.out.println("模拟面试是 Plus 会员专享功能");
    }
}
```

PLUS 会员：

```java
class Plus implements IUser {

    @Override
    public void mockInterview() {
        System.out.println("开始模拟面试");
    }
}
```

每个状态类都实现了 IUser 接口，在接口方法中实现自己特定的行为。

用户类：

```java
class User implements IUser, ISwitchState {

    IUser state = new Normal();

    @Override
    public void mockInterview() {
        state.mockInterview();
    }

    @Override
    public void purchasePlus() {
        state = new Plus();
    }

    @Override
    public void expire() {
        state = new Normal();
    }
}
```

可以看到，丑陋的状态判断语句消失了，无论 IUser 接口中有多少方法，User 类都只需要调用状态类的对应方法即可。

客户端测试：

```java
public class Client {

    @Test
    public void test() {
        // 用户初始状态为普通用户
        User user = new User();
        // 输出：模拟面试是 Plus 会员专享功能
        user.mockInterview();

        // 用户购买 Plus 会员，状态改变
        user.purchasePlus();
        // 输出：开始模拟面试
        user.mockInterview();

        // Plus 会员过期，变成普通用户，状态改变
        user.expire();
        // 输出：模拟面试是 Plus 会员专享功能
        user.mockInterview();
    }
}
```

可以看到，用户状态改变后，行为也随着改变了，这就是状态模式定义的由来，它的优点是：将与特定状态相关的行为封装到一个状态对象中，使用多态代替 if-else 或者 switch-case 状态判断。缺点是必然导致类增加，这也是使用多态不可避免的缺点。

![image-20230614165418269](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-202306141654182693Ct95D.png)

# 21 策略模式

策略模式（Strategy Pattern）：定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。

通过策略模式我们可以为同一个需求选择不同的算法，以应付不同的场景。比如我们知道冒泡排序和插入排序是稳定的，而选择排序是不稳定的，当我们需要保证排序的稳定性就可以采用冒泡排序和插入排序，不需要保证排序的稳定性时可以采用选择排序。

策略模式还可以应用在图片缓存中，当我们开发一个图片缓存框架时，可以通过提供不同的策略类，让用户根据需要选择缓存解码后的图片、缓存未经解码的数据或者不缓存任何内容。在一些开源的图片加载框架中，就采用了这种设计。

策略模式扩展性和灵活性都相当不错。当有新的策略时，只需要增加一个策略类；要修改某个策略时，只需要更改具体的策略类，其他地方的代码都无需做任何调整。

但现在这样的策略模式还有一个弊端，如本系列第一篇文章中的工厂模式所言：每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。

所以使用策略模式时，更好的做法是与工厂模式结合，将不同的策略对象封装到工厂类中，用户只需要传递不同的策略类型，然后从工厂中拿到对应的策略对象即可。

策略模式与状态模式非常类似，甚至他们的 UML 类图都是一模一样的。两者都是采用一个变量来控制程序的行为。策略模式通过不同的策略执行不同的行为，状态模式通过不同的状态值执行不同的行为。两者的代码很类似，他们的区别主要在于程序的目的不同。

- 使用策略模式时，程序只需选择一种策略就可以完成某件事。也就是说每个策略类都是完整的，都能独立完成这件事情，如上文所言，强调的是`殊途同归`。
- 使用状态模式时，程序需要在不同的状态下不断切换才能完成某件事，每个状态类只能完成这件事的一部分，需要所有的状态类组合起来才能完整的完成这件事，强调的是`随势而动`。

![image-20230614165822710](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614165822710Cw7lTf.png)

```java
public abstract class Duck {
  private FlyBehavior flyBehavior;
  
  public void fly() {
    flyBehavior.perform();
  }
}

public class RedDuck extends Duck {
  pubic RedDuck {
    this.flyBehavior = new FlyBehaviorImplementA();
  }
}

public class FlyBehaviorImplementA implements FlyBehavior {
  public void perform() {
    // ...
  }
}

```









# 22 模板方法模式

> 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

在使用模板方法模式时，我们可以为不同的模板方法设置不同的控制权限：

- 如果不希望子类覆写模板中的某个方法，使用 final 修饰此方法；
- 如果要求子类必须覆写模板中的某个方法，使用 abstract 修饰此方法；
- 如果没有特殊要求，可使用 protected 或 public 修饰此方法，子类可根据实际情况考虑是否覆写。

![image-20230614165959332](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614165959332vd2RQe.png)

# 23 访问者模式

访问者模式的核心思想：将`数据的结构`和`对数据的操作`分离。

> 访问者模式（Visitor Pattern）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

![image-20230614170106720](https://gitee.com/chLemon/pictures/raw/master/Picsee/image-20230614170106720FBr2lM.png)

许多设计模式的书中都说访问者模式是最复杂的设计模式，实际上只要我们对它抽丝剥茧，就会发现访问者模式的核心思想并不复杂。

以我们去吃自助餐为例，每个人喜欢的食物是不一样的，比如 Aurora 喜欢吃龙虾和西瓜，Kevin 喜欢吃牛排和香蕉，餐厅不可能单独为某一位顾客专门准备食物。所以餐厅的做法是将所有的食物都准备好，顾客按照需求自由取用。此时，顾客和餐厅之间就形成了一种访问者与被访问者的关系。

准备好各种食物的餐厅：

```java
class Restaurant {
    private String lobster = "lobster";
    private String watermelon = "watermelon";
    private String steak = "steak";
    private String banana = "banana";
}
```

在餐厅类中，我们提供了四种食物：龙虾、西瓜、牛排、香蕉。

为顾客提供的接口：

```java
public interface IVisitor {
    void chooseLobster(String lobster);

    void chooseWatermelon(String watermelon);

    void chooseSteak(String steak);

    void chooseBanana(String banana);
}
```

接口中提供了四个方法， 让顾客依次选择每种食物。

在餐厅中提供接收访问者的方法：

```java
class Restaurant {
    ...

    public void welcome(IVisitor visitor) {
        visitor.chooseLobster(lobster);
        visitor.chooseWatermelon(watermelon);
        visitor.chooseSteak(steak);
        visitor.chooseBanana(banana);
    }
}
```

在 welcome 方法中，我们将食物依次传递给访问者对应的访问方法。这时候，顾客如果想要访问餐厅选择自己喜欢的食物，只需要实现 IVisitor 接口即可。

比如顾客 Aurora 类：

```java
public class Aurora implements IVisitor {
    @Override
    public void chooseLobster(String lobster) {
        System.out.println("Aurora gets a " + lobster);
    }

    @Override
    public void chooseWatermelon(String watermelon) {
        System.out.println("Aurora gets a " + watermelon);
    }

    @Override
    public void chooseSteak(String steak) {
        System.out.println("Aurora doesn't like " + steak);
    }

    @Override
    public void chooseBanana(String banana) {
        System.out.println("Aurora doesn't like " + banana);
    }
}
```

在此类中，顾客根据自己的喜好依次选择每种食物。

客户端测试：

```java
public class Client {
    @Test
    public void test() {
        Restaurant restaurant = new Restaurant();
        IVisitor Aurora = new Aurora();
        restaurant.welcome(Aurora);
    }
}
```

运行程序，输出如下：

```text
Aurora gets a lobster
Aurora gets a watermelon
Aurora doesn't like steak
Aurora doesn't like banana
```

可以看到，Aurora 对每一种食物做出了自己的选择，这就是一个最简单的访问者模式，它已经体现出了访问者模式的核心思想：将`数据的结构`和`对数据的操作`分离。

> 访问者模式（Visitor Pattern）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

本例中，顾客需要选择餐厅的食物，由于每个顾客对食物的选择是不一样的，如果在餐厅类中处理每位顾客的需求，必然导致餐厅类职责过多。所以我们并没有在餐厅类中处理顾客的需求，而是将所有的食物通过接口暴露出去，欢迎每位顾客来访问。顾客只要实现访问者接口就能访问到所有的食物，然后在接口方法中做出自己的选择。

相信这个例子还是非常简单直观的，看起来访问者模式也不是那么难理解。那么为什么很多书中说访问者模式是最复杂的设计模式呢？原因就在于《设计模式》一书中给访问者模式设计了一个“双重分派”的机制，而 Java 只支持单分派，用单分派语言强行模拟出双重分派才导致了访问者模式看起来比较复杂。要理解这一点，我们先来了解一下何谓单分派、何谓双重分派。

## **单分派与双重分派**

先看一段代码：

Food 类：

```java
public class Food {
    public String name() {
        return "food";
    }
}
```

Watermelon 类，继承自 Food 类：

```java
public class Watermelon extends Food {
    @Override
    public String name() {
        return "watermelon";
    }
}
```

在 Watermelon 类中，我们重写了`name()`方法。

客户端：

```java
public class Client {
    @Test
    public void test() {
        Food food = new Watermelon();
        System.out.println(food.name());
    }
}
```

思考一下，在客户端中，我们 new 出了一个 Watermelon 对象，但他的声明类型是 Food，当我们调用此对象的 name 方法时，会输出 "food" 还是 "watermelon" 呢？

了解过 Java 多态特性的同学都知道，这里肯定是输出 "watermelon" ，因为 Java 调用重写方法时，会根据运行时的具体类型来确定调用哪个方法。

再来看一段测试代码：

```java
public class Client {
    @Test
    public void test() {
        Food food = new Watermelon();
        eat(food);
    }

    public void eat(Food food) {
        System.out.println("eat food");
    }

    public void eat(Watermelon watermelon) {
        System.out.println("eat watermelon");
    }
}
```

在这段代码中，我们仍然 new 出了一个 Watermelon 对象，他的声明类型是 Food，在客户端中有`eat(Food food)`和`eat(Watermelon watermelon)`两个重载方法，这段代码会调用哪一个方法呢？

我们运行这段代码会发现输出的是：

```text
eat food
```

这是由于 Java 在调用重载方法时，只会根据方法签名中声明的参数类型来判断调用哪个方法，不会去判断参数运行时的具体类型是什么。

从这两个例子中，我们可以看出 Java 对重写方法和重载方法的调用方式是不同的。

- 调用重写方法时，与对象的运行时类型有关；
- 调用重载方法时，只与方法签名中声明的参数类型有关，与对象运行时的具体类型无关。

了解了重写方法和重载方法调用方式的区别之后，我们将其综合起来就能理解何谓双重分派了。

测试代码：

```java
public class Client {
    @Test
    public void test() {
        Food food = new Watermelon();
        eat(food);
    }

    public void eat(Food food) {
        System.out.println("eat food: " + food.name());
    }

    public void eat(Watermelon watermelon) {
        System.out.println("eat watermelon" + watermelon.name());
    }
}
```

在这段测试代码中，仍然是 new 出了一个 Watermelon 对象，它的声明类型为 Food。运行`test()`函数，输出如下：

```text
eat food: watermelon
```

在面向对象的编程语言中，我们将方法调用称之为`分派`，这段测试代码运行时，经过了两次分派：

- 调用重载方法：选择调用`eat(Food food)`还是`eat(Watermelon watermelon)`。虽然这里传入的这个参数实际类型是`Watermelon`，但这里会调用`eat(Food food)`，这是由于调用哪个重载方法是在编译期就确定了的，也称之为`静态分派`。
- 调用重写方法：选择调用`Food`的`name`方法还是`Watermelon`的`name`方法。这里会根据参数运行时的实际类型，调用`Watermelon`的`name`方法，称之为`动态分派`。

单分派、双重分派的定义如下：

> 方法的接收者和方法的参数统称为方法的宗量。 根据分派基于多少个宗量，可以将分派分为单分派和多分派。单分派是指根据一个宗量就可以知道应该调用哪个方法，多分派是指需要根据多个宗量才能确定调用目标。

这段定义可能不太好理解，通俗地讲，单分派和双重分派的区别就是：程序在选择重载方法和重写方法时，如果两种情况都是动态分派的，则称之为双重分派；如果其中一种情况是动态分派，另一种是静态分派，则称之为单分派。

说了这么多，这和我们的访问者模式有什么关系呢？首先我们要知道，架构的演进往往都是由复杂的业务驱动的，当程序需要更好的扩展性，更灵活的架构便诞生出来。

上例中的程序非常简单，但它无法处理某种食物有多个的情形。接下来我们就来修改一下程序，来应对每种食物有多个的场景。

## **自助餐程序 2.0 版**

在上面的例子中，为了突出访问者模式的特点，我们将每种食物都简化为了 String 类型，实际开发中，每种食物都应该是一个单独的对象，统一继承自父类 Food：

```java
public abstract class Food {
    public abstract String name();
}
```

继承自 Food 的四种食物：

龙虾：

```java
public class Lobster extends Food {
    @Override
    public String name() {
        return "lobster";
    }
}
```

西瓜：

```java
public class Watermelon extends Food {
    @Override
    public String name() {
        return "watermelon";
    }
}
```

牛排：

```java
public class Steak extends Food {
    @Override
    public String name() {
        return "steak";
    }
}
```

香蕉：

```java
public class Banana extends Food {
    @Override
    public String name() {
        return "banana";
    }
}
```

四个子类中分别重写了 name 方法，返回自己的食物名。

IVisitor 接口对应修改为：

```java
public interface IVisitor {
    void chooseFood(Lobster lobster);

    void chooseFood(Watermelon watermelon);

    void chooseFood(Steak steak);

    void chooseFood(Banana banana);
}
```

每种食物都继承自 Food，所以我们将接口中的方法名都修改为了 chooseFood。

餐厅类修改如下：

```java
class Restaurant {

    // 准备当天的食物
    private List<Food> prepareFoods() {
        List<Food> foods = new ArrayList<>();
        // 简单模拟，每种食物添加 10 份
        for (int i = 0; i < 10; i++) {
            foods.add(new Lobster());
            foods.add(new Watermelon());
            foods.add(new Steak());
            foods.add(new Banana());
        }
        return foods;
    }

    // 欢迎顾客来访
    public void welcome(IVisitor visitor) {
        // 获取当天的食物
        List<Food> foods = prepareFoods();
        // 将食物依次提供给顾客选择
        for (Food food : foods) {
            // 由于单分派机制，此处无法编译通过
            visitor.chooseFood(food);
        }
    }
}
```

餐厅类中新增了`prepareFoods`方法，在这个方法中，我们简单模拟了准备多个食物的过程，将每种食物添加了 10 份。在接收访问者的`welcome`方法中，遍历所有食物，分别提供给顾客。

看起来很美好，实际上，`visitor.chooseFood(food)`这一行是无法编译通过的，原因就在于上一节中提到的单分派机制。虽然每种食物都继承自 Food 类，但由于接口中没有`chooseFood(Food food)`这个重载方法，所以这一行会报错"Cannot resolve method chooseFood"。

试想，如果 Java 在调用重载方法时也采用动态分派，也就是根据参数的运行时类型选择对应的重载方法，这里遇到的问题就迎刃而解了，我们的访问者模式讲到这里也就可以结束了。

但由于 Java 是单分派语言，所以我们不得不想办法解决这个 bug，目的就是**使用单分派的 Java 语言模拟出双分派的效果，能够根据运行时的具体类型调用对应的重载方法**。

我们很容易想到一种解决方式，采用 instanceOf 判断对象的具体子类型，再将父类强制转换为具体子类型，调用对应的接口方法：

```java
// 通过 instanceOf 判断具体子类型，再强制向下转型
if (food instanceof Lobster) visitor.chooseFood((Lobster) food);
else if (food instanceof Watermelon) visitor.chooseFood((Watermelon) food);
else if (food instanceof Steak) visitor.chooseFood((Steak) food);
else if (food instanceof Banana) visitor.chooseFood((Banana) food);
else throw new IllegalArgumentException("Unsupported type of food.");
```

的确可行，在某些开源代码中便是这么做的，但这种强制转型的方式既冗长又不符合开闭原则，所以《设计模式》一书中给我们推荐了另一种做法。

首先在 Food 类中添加 accept(Visitor visitor) 抽象方法：

```java
public abstract class Food {
    public abstract String name();

    // Food 中添加 accept 方法，接收访问者
    public abstract void accept(IVisitor visitor);
}
```

在具体子类中，实现此方法：

```java
public class Lobster extends Food {
    @Override
    public String name() {
        return "lobster";
    }

    @Override
    public void accept(IVisitor visitor) {
        visitor.chooseFood(this);
    }
}
```

经过这两步修改，餐厅类就可以将接收访问者的方法修改如下：

```java
class Restaurant {

    // 准备当天的食物
    private List<Food> prepareFoods() {
        List<Food> foods = new ArrayList<>();
        // 简单模拟，每种食物添加 10 份
        for (int i = 0; i < 10; i++) {
            foods.add(new Lobster());
            foods.add(new Watermelon());
            foods.add(new Steak());
            foods.add(new Banana());
        }
        return foods;
    }

    // 欢迎顾客来访
    public void welcome(IVisitor visitor) {
        // 获取当天的食物
        List<Food> foods = prepareFoods();
        // 将食物依次提供给顾客选择
        for (Food food : foods) {
            // 由于重写方法是动态分派的，所以这里会调用具体子类的 accept 方法，
            food.accept(visitor);
        }
    }
}
```

经过这三步修改，我们将访问者来访的代码由：

```text
visitor.chooseFood(food);
```

改成了

```text
food.accept(visitor);
```

这样我们就将重载方法模拟成了动态分派。这里的实现非常巧妙，由于 Java 调用重写方法时是动态分派的，所以`food.accept(visitor)`会调用具体子类的 accept 方法，在具体子类的 accept 方法中，调用`visitor.chooseFood(this)`，由于这个 accept 方法是属于具体子类的，所以这里的 this 一定是指具体的子类型，不会产生歧义。

再深入分析一下：之前的代码中，调用`visitor.chooseFood(food)`这行代码时，由于重载方法不知道 Food 的具体子类型导致了编译失败，但实际上这时我们是可以拿到 Food 的具体子类型的。利用重写方法会动态分派的特性，我们在子类的重写方法中去调用这些重载的方法，使得重载方法使用起来也像是动态分派的一样。

顾客 Aurora 类：

```java
public class Aurora implements IVisitor {

    @Override
    public void chooseFood(Lobster lobster) {
        System.out.println("Aurora gets a " + lobster.name());
    }

    @Override
    public void chooseFood(Watermelon watermelon) {
        System.out.println("Aurora gets a " + watermelon.name());
    }

    @Override
    public void chooseFood(Steak steak) {
        System.out.println("Aurora doesn't like " + steak.name());
    }

    @Override
    public void chooseFood(Banana banana) {
        System.out.println("Aurora doesn't like " + banana.name());
    }
}
```

顾客 Kevin 类：

```java
public class Kevin implements IVisitor {

    @Override
    public void chooseFood(Lobster lobster) {
        System.out.println("Kevin doesn't like " + lobster.name());
    }

    @Override
    public void chooseFood(Watermelon watermelon) {
        System.out.println("Kevin doesn't like " + watermelon.name());
    }

    @Override
    public void chooseFood(Steak steak) {
        System.out.println("Kevin gets a " + steak.name());
    }

    @Override
    public void chooseFood(Banana banana) {
        System.out.println("Kevin gets a " + banana.name());
    }
}
```

客户端测试：

```java
public class Client {
    @Test
    public void test() {
        Restaurant restaurant = new Restaurant();
        IVisitor Aurora = new Aurora();
        IVisitor Kevin = new Kevin();
        restaurant.welcome(Aurora);
        restaurant.welcome(Kevin);
    }
}
```

运行程序，输出如下：

```text
Aurora gets a lobster
Aurora gets a watermelon
Aurora doesn't like steak
Aurora doesn't like banana
... 输出 10 遍
Kevin doesn't like lobster
Kevin doesn't like watermelon
Kevin gets a steak
Kevin gets a banana
... 输出 10 遍
```

这就是访问者模式，它的核心思想其实非常简单，就是第一小节中体现的将`数据的结构`与`对数据的操作`分离。之所以说它复杂，主要在于大多数语言都是单分派语言，所以不得不模拟出一个双重分派，也就是**用重写方法的动态分派特性将重载方法也模拟成动态分派**。

但模拟双重分派只是手段，不是目的。有的文章中说模拟双重分派是访问者模式的核心，还有的文章中说双分派语言不需要访问者模式，笔者认为这些说法都有点舍本逐末了。