> 我是在学习完Java后重学的C语言，故本笔记中有一些诸如”整数除法会舍弃余数“之类的所有语言通用的点并未进行记录。
>
> 《C程序设计语言》（第2版）Brian W.Kernighan, Dennis M.Ritchie著，徐宝文 李志译，机械工业出版社

# 第一章 导言

本章大致介绍了一下C语言程序的基本框架，根据几个例子介绍了一下常用的语法。

## HelloWorld

```c
#include <stdio.h>

main()
{
    printf("hello, world\n");
}
```

编译：以Unix为例

```
cc hello.c
```

得到`a.out`，执行即可，不同的操作系统编译命令可能有所不同

## 注释

```
//
/*   */
```

C语言中所有变量必须先声明再使用

## 数据类型

```
int 
float
char
short
long
double
```

具体大小取决于具体机器

### while、if和for

单条语句可以不加花括号

### printf

该函数由标准库函数提供，可以控制打印宽度和对齐，例如

```
printf("%3d %6d %6.1f",a,b,c);
```

前面的数字表示**宽度**，浮点数小数点后面的表示**小数点的位置**，均可省略，**默认右对齐**，左对齐在百分号**后面加负号**-

```
%o	八进制
%d	十六进制
%c	字符
%s	字符串
%%	百分号本身
%f  float和double
```

### 符号常量

```
#define 名字 替换内容
```

注意末尾没有分号，会将代码中的`名字`部分全部替换为`替换内容`

### 字符输入和输出

**字符流**，每行字符由0或多个字符组成，行末是换行符。

```
char c;
c = getchar();//从文本流中读下一个字符
putchar(c);//打印
```

### EOF

`EOF`，end of file表示文件结束

定义在`<stdio.h>`里面，是个`int`，所以用`int`去接收`getchar()`的返回（要能接收`EOF`)

```
#include <stdio.h>

main()
{
	int c;
	while((c = getchar()) != EOF)
		putchar();
}
```

这里的条件表达式，判断的是c是否为`EOF`，**赋值语句也是一个表达式，值为赋值后左边变量保存的值**

键盘输入`EOF`：`Ctrl + Z`

### 空语句

单独一个分号组成的语句，什么都不做。for循环必须要有循环体

```
;
```

### while和for

会先进行判断，所以可能1次都不执行

for循环的3部分：初始化部分、条件部分、步进部分

### 字符常量

**单引号**的字符，小的整型数的另一种写法

### 函数

+ 函数的使用必须先声明，称为*函数原型*，参数名可以不写，只写类型，但是写了能起到很好的说明作用。主要用来辅助编译。

函数定义可以以任意次序出现在一个源文件或多个源文件中，但同一函数不能分割在多个文件中，这是由于操作系统决定的，因为编译和加载会很麻烦

+ 函数的默认返回值为`int`，不写的就是`int`

#### 传值调用

**所有函数参数都是“传值调用”**，所以需要指针，数组名参数传递过来的是起始位置的地址

```
int getline(char s[], int lim);
```

一般把圆括号内列表中出现的变量称为形式参数，把函数调用中与形式参数对应的值称为实际参数。return不是必须的，main应该return一个数，一般return 0表示正常终止，返回给执行环境



函数原型与函数声明中的参数名不要求相同，事实上函数原型中的参数名可以不写，但是写上能起到很好的说明作用

### getline

读取输入的下一行，返回长度，0表示遇到了`EOF`，只包含换行符`\n`的行长度为1

### 字符串的结尾

约定空字符`'\0'`，其值为0，为字符串的结束标志。

### 变量类型

局部变量 = 私有变量 = 自动变量

全局变量 = 外部变量

使用外部变量的时候，可以用extern语句显示声明。如果外部变量声明在使用之前，可以省略。所以一般我们都把外部变量写在最开头

```
int max;
main()
{
	extern max;
	max += 1;
}
```

如果声明和使用在不同文件里，就必须写，通常我们会把 变量和函数的`extern`声明放在一个单独的文件里，习惯上称为**头文件**，并在每个文件的开头使用#include把头文件包含进来

# 第二章 类型、运算符与表达式

所有整形都有`signed`和`unsigned`两种形式。

## 2.1 变量名

字母和数字组成，第一个字符必须是字母。大小写敏感。

下划线`_`被看作是字母，库例程（library routines）通常以下划线开头，变量名不要以下划线开头。

传统写法中，变量名使用小写字母，符号常量名字用大写字母。

对内部变量的名称，至少前31个字符有效，即当内部变量名超过31个字符时候，它们的前31位都相同，那么编译器可能会认为它们是同名变量。

函数名和外部变量的名称，有效字符数目可能小于31，因为汇编和加载程序需要用这些外部名。

对于外部变量名，ANSI标准仅保证前6个字符的唯一性，并不区分大小写。

## 2.2 数据类型及长度

基本数据类型：

```c
char	  //一个字节，较小的整型
int		  //通常反映了机器中整数的最自然长度
float	  //单精度浮点型
double	//双精度浮点型
  
//可以加上用于整型的限定符，int可以省略
short int
long int
  
long double  //长度取决于具体的实现
```

`short`至少16位，`long`至少32位，`int`根据机器可能是16或32位。`short < int < long`

`unsigned`和`signed`可以用于限定所有整形，包括`char`

可以打印的字符总是正数

有关类型长度定义的符号常量可以在标准头文件`<limits.h>`和`<float.h>`里找到

## 2.3 常量

```c
5             //int，整数
5L            //long，以l或L结尾的整数
1.5           //double，小数或指数形式
1e-2          //double
1.5f          //float，以f或F结尾的小数
1.5L          //long double，以l或L结尾的小数
010           //8进制的8，以0开头的数字
0x1f          //16进制的31，以0x或0X开头的数字
'a'           //char，字符型常量，是一个小的整数
'\0'          //数字值为0的字符，空字符null，为了强调字符属性这样写
\n            //char，是一个字符，\表示转义，转义字符
\013          //013是8进制，\表示转义，相当于\v，形式：\ooo
\xb           //b是16进制，\表示转义，相当于\v，形式：\xhh
```

常量表达式在编译时求值

编译时可以将多个字符串常量连接起来

C语言对字符串的长度没有限制

### 2.3.1 枚举常量 

```c
enum boolean {NO , YES}；
```

枚举是一个常量整型值的列表

没有显示说明的情况下，enum类型中第一个枚举名的值为0，第二个为1，以此类推。如果制定了部分，那么未指定的枚举名的值将依着最后一个指定值向后递增。

```c
enum months{ JAN = 1, FEB,...};
```

+ 不同枚举中的名字必须互不相同，同一枚举中不同的名字可以具有相同的值。可以理解成作用域很大，编译阶段的宏`#define`

也有枚举变量，此处不讨论

## 2.4 声明

+ 所有变量都必须先声明后使用

同类型的多个变量可以在一行声明，也可拆开，拆开便于加注释和以后修改。

+ 可以在声明的同时进行初始化：

  非局部变量，只能初始化一次，而且初始化表达式必须是常量表达式。如果不显式初始化，初始化0。

  局部变量，每次进入函数或程序块，都会被初始化一次，其初始化表达式可以是任何表达式。未显式初始化的局部变量的值为未定义值（无效值）。

任何变量的声明都可以用`const`限定符限定，表示指定变量的值不能被修改

对数组而言，`const`限定符指定的数组所有元素的值都不能被修改

也可以搭配数组参数使用，表明函数不能修改数组元素的值

```c
int strlen(const char[]);
```

如果视图修改`const`限定符限定的值，其结果取决于具体的实现

## 2.5 算数运算符

有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现

## 2.6 关系运算符、逻辑运算符

关系表达式和逻辑表达式的判定结果为真时，表达式的值为1；判定结果为假时，表达式的值为0。但是某些函数，如`isdigit`在结果为真时可能返回任意的非0值。

## 2.7 类型转换

`<ctype.h>`提供的测试和转换函数和字符集无关，所以尽可能的用`tolower(c)`之类的函数而不是`c - 'a'`。

C语言定义保证了机器的标准打印字符集不会是负值，但是其他的`char`可能在某些机器里是负的，而在另一些机器上是正的，所以要用`char`存储非字符数据时，最好指定`signed`或`unsigned`

自动转换是将范围比较窄的操作数转为比较宽的操作数。

注意`float`不会自动转换为`double`，使用`float`主要是为了在使用较大数组时节省空间，有时候也为了节省时间（双精度算数运算特别费时）

+ 当较长的整数转换为较短的整数的时候，高位会被舍弃。
+ 当小数转换为整数时，小数部分将被截取。
+ 当`double`转换为`float`的时，是进行四舍五入还是截取取决于具体的实现。

赋值和参数传递的时候会进行类型转换，所以我们可以把函数参数声明为`int`和`double`，哪怕实际传入的参数是`short`或`float`



强制转换：

```c
sqrt((double) n)
```

通常情况下，参数是通过函数原型声明的，这样函数在调用的时候会对参数进行强制类型转换。

## 2.8 自增运算符和自减运算符

自增和自减运算符只能作用于变量。

```c
x = ++n;     // x = n + 1;
x = n++      // x = n;
```

## 2.9 按位运算符

只能操作整型操作数。

对于`unsigned`类型的整数，左移和右移都补0。对于`signed`类型，右移：有的机器会补充符号位（算数移位），有的机器会补0（逻辑移位）。

写位运算尽量写的有“可移植性”，如

```c
x &= ~077;                //上面的这个更好，因为下面的假设了x是16位的
x &= 0177700;
```

## 2.10 赋值运算符与表达式

```c
expr1 += expr2;             //这个对expr1只需要计算一次
expr1 = expr1 + expr2;
```

赋值语句具有值，赋值表达式的类型是它的左操作数的类型，值是赋值操作完成后的值。

## 2.11 条件表达式

```c
(n > 0) ? f : n          //这个括号不是必须的，因为条件运算符的优先级非常低，但是为了阅读性，最好还是加上
```

## 2.12 运算符优先级与求值次序

+ 优先级问题记得加括号就好

**求值次序：**

C语言没有指定同一运算符中多个操作数的计算顺序（`&&`，`||`，`?:`，`, `除外）

```c
x = f() + g();
printf("%d %d\n", ++n, power(2, n));
```

`f()`和`g()`的运算顺序不确定，如果互相会有影响，那么得到的结果不确定。下面也是同理。



```c
() [] -> .
! ~ ++ -- + - * & (type) sizeof				（从右至左）
* / %
+ -
<< >>
< <= > >=
== !=
&
^
|
&&
||
?:                                 		（从右至左）
= += -= *= /= %= &=                		（从右至左）
^= |= <<= >>=
,
```

# 第三章 控制流

## 3.1 语句与程序块

`;`分号是语句结束符，`{}`将多个语句和声明括在一起构成复合语句，也叫程序块，在语法上等价于单条语句。

## 3.2 if-else语句

`else`会匹配最近的一个`if`，所以要注意加花括号来实现正确的匹配关系，如：

```c
if(n >= 0)
  for (i = 0, i < n; i++)
    if(s[i] > 0) {
      printf("...");
      return i;
    }
else                 /*  错误！实际上这个else会匹配for循环内的if  */
  printf("error -- n is negative\n");
```

## 3.3 else-if语句

多路判定最常用的方法

## 3.4 switch语句

测试表达式是否与**常量**整数值匹配

跳出`switch`语句的方法：`break`和`return`

尽量给每个`case`都加上`break`，除非一个计算需要多个`case`标号，在不得不使用的情况下应该加上注释

`default`可以不加`break`，但是作为一种良好的程序设计风格，也应该加上，这样在扩展`switch`的时候，会降低犯错的可能性

## 3.5 while循环和for循环

这两个循环都是先判断，再执行循环体

`for`循环：*初始化*和*步进部分*可以是赋值表达式或函数调用，*条件判断部分*是关系表达式，任一部分都可以省略，但是分号必须保留。

省略*初始化*和*步进部分*则等价于`while`循环，省略*条件判断部分*，则为死循环

### 逗号运算符`,`

C语言优先级最低的运算符，在`for`语句中经常会用到，被逗号运算符分隔的一对表达式将按照从左到右的顺序进行求值，例如：

```c
for (i = 0, j = strlen(s) - 1; i < j; i++, j--) {
  c = s[i], s[i] = s[j], s[j] = c;
}
```

某些情况下的逗号并不是逗号运算符，如分隔函数参数的逗号，分隔声明中变量的逗号等，这些逗号不保证表达式从左到右的顺序

应该慎重使用逗号运算符，一般会在关系紧密的结构中使用，如`for`循环，在单个表达式里进行多步计算的宏

## 3.6 do-while循环

可以保证至少执行一次循环体

## 3.7 break语句与continue语句

对于`while`和`do-while`语句来说，`continue`意味着立即执行条件判断

对于`for`语句来说，`continue`意味着立即执行步进部分

## 3.8 goto语句与标号

大多数情况下，`goto`语句比较难以理解和维护，应该尽量少的使用goto语句

```c
for (...)
  for (...) {
    ...
    if (disaster)
      goto error;
  }
...
  
error:
  处理错误情况
```

`goto`后面跟标号，标号的命名规则和变量命名规则相同，标号后面紧跟一个冒号，作用域是整个函数。标号可以位于goto语句所在函数的任何语句的前面。

# 第四章 函数与程序结构

一个程序可以保存在一个或者多个源文件中，各个文件可以单独编译。

## 4.1 函数的基本知识

```c
返回值类型 函数名(参数声明表)
{
  声明和语句
}
```

各部分都可以省略，最简单的函数：

```c
dummy() {}
```

这种什么都没有的函数，可以在开发的时候用来保留位置，留待以后填充

+ 如果省略了返回值类型，则默认为`int`

只要保证每一个函数不被分离到多个文件中，源程序就可以分为多个文件。



**编译和加载**

不同操作系统机制不同，以Unix系统为例，编译可以`cc main.c getline.c strindex.c`，如果`main`存在了错误，还可以`cc main.o getline.o strindex.o`重新编译，`cc`命令用`.c`和`.o`两种扩展名来区分源文件与目标文件

## 4.2 返回非整型值的函数

声明函数：

可以在调用函数内显式声明

```c
int main()
{
  double sum, atof(cahr []);     //声明一个变量和一个函数
  ...
}
```

如果`atof`和`main`在同一个源文件里，那么编译器就可以对`atof`的声明和定义进行一致性检验。

但是如果`atof`在另一个文件里，那么就不会进行这种检验。

如果没有函数原型，那么函数将在第一次出现的表达式中被隐式声明。假定返回值为`int`，对参数不作假设。如果函数声明中没有参数，则不会对参数进行检查（为了兼容老版本C语言）。

+ `return`前会自动进行强制类型转换，但是有的编译器会报警告，可以手动加上一个强制类型转换。

## 4.3 外部变量

C语言不允许在函数内定义函数

默认情况下，函数和外部变量：通过同一个名字对他们的引用都是引用的同一个对象。（全局变量）

外部变量永久存在，作用域和生存期更长。

## 4.4 作用域规则

局部变量：声明该变量的函数

外部变量和函数：从声明它的地方开始，到所在文件的末尾

+ 如果要在外部变量定义之前使用它，或者外部变量的定义与使用不在同一个文件中，必须在变量声明中使用关键字`extern`

**定义和声明**

```c
//定义，会分配存储单元，一个程序的所有源文件中只能有一次
int sp;
double val[MAXVAL];   //定义必须指定数组长度

//声明，不会分配存储单元，可以在文件里多次声明
extern int sp;
extern double val[];  //声明不一定指定数组长度
```

外部变量的初始化只能出现在其定义中。

## 4.5 头文件

可以把每个文件都共享的部分放在头文件里，最好只用一个头文件，否则就要精心设计好。经常用来存一堆`extern`和`#define`

## 4.6 静态变量

`static`可以限定外部变量和函数，被限定对象的作用域被限定在该文件的剩余部分，可以隐藏外部对象。

也可以限定局部变量，作用是使得变量一直存在，不会随着函数被调用和退出而存在和消失。

## 4.7 寄存器变量

`register`声明告诉编译器，该变量使用频率较高，想存在寄存器里，但是编译器可以忽略此选项。

只适用于自动变量以及函数的形式参数。

过量的寄存器声明并没有什么害处，因为编译器可以忽略过量的或者不支持的寄存器变量声明。寄存器变量的地址不能访问。

## 4.8 程序块结构

变量的声明可以跟在函数开始的花括号后，也可以跟在任何复合语句的左花括号后。

静态变量只在第一次进入程序块时被初始化一次。

## 4.9 初始化

没有显式初始化的话，外部变量和静态变量会被初始化为0。

初始化可以在定义的同时进行。

外部变量和静态变量只能使用常量表达式初始化。

自动变量和寄存器变量，可以使用非常量表达式。

+ 一般会使用显式的赋值语句，因为在声明中初始化容易被忽略，而且距使用的位置较远

数组初始化可以直接跟一个花括号列表，未声明长度的话会根据花括号内初始化表达式的个数作为数组的长度。

如果初始化表达式的个数比数组元素少，则对外部变量、静态变量、自动变量来说，没有初始化的元素会被初始化为0。

字符数组可以用字符串来代替花括号的初始化表达式，并会在结尾加上`\0`

## 4.10 递归

调用自身，代码紧凑，效率不高。

## 4.11 C预处理器

预处理器是编译过程中单独执行的第一个步骤。2个最常用的预处理器指令是`#include`指令和`#define`指令

### 4.11.1 文件包含

```c
#include "文件名"     //在源文件所在的位置查找，如果没有找到，同尖括号
#include <文件名>     //根据相应规则查找，同具体实现有关
```

文件包含指令，会将`#include`行替换文*文件名*指定的文件的内容。

一般包含常见的`#define`语句和`extern`声明等

### 4.11.2 宏替换

```c
#define 名字 替换文本
```

后续所有*名字*记号的地方都会被替换为*替换文本*。

名字与变量名命名方式相同，替换文本可以是任意字符串。

如果`#define`要写多行，需要在行末加上反斜杠符`\`

作用域从定义点到文件的末尾

宏定义里也可以使用之前出现过的宏定义

替换只对记号作用，对括在引号中的字符串不起作用

宏定义可以带参数：

```c
#define max(A, B) ((A) > (B) ? (A) : (B))

x = max(p+q, r+s);
x = ((p+q) > (r+s) ? (p+q) : (r+s));
```

可以将同一个宏定义应用于任何数据类型，而无需针对不同的数据类型定义不同的max函数

缺点：参数表达式要重复计算2次，在存在自增运算符或输入/输出的时候回导致结果不正确

`#undef`取消名字的宏定义，保证后续的调用时函数调用，而不是宏调用



形式参数不能用带引号的字符串替换，但是可以使用`#`作为前缀将结果扩展为由实际参数替换该参数的带引号的字符串

```
#define test(a) "a"
a不会被替换

#define dprint(expr) printf(#expr " = %g\n", expr)

dprint(x/y);

printf("x/y" " = %", x/y);
其中字符串被连接起来了，等价于
printf("x/y = ")
```

在实际参数中，每个双引号将被替换为`\"`，反斜杠`\`将被替换为`\\`



`##` 如果替换文本中的参数与`##`响铃，则该参数将被实际参数替换，`##`与前后的空白符将被删除

```c
#define paste(front, back) front ## back


paste(name, 1)将变成name1
```

### 4.11.3 条件包含

可以用条件语句对预处理本身进行控制

```c
#if !defined(HDR)
若#if气候的表达式不为0，则包含其后的各行，直到遇到#endif  #elif   #else为止
#define HDR
#endif
  
  
C语言  专门定义了两个预处理语句 #ifdef  #ifndef 用来测试某个名字是否已经定义
```

# 第五章 指针与数组

指针是一种保存变量地址的**变量**。

## 5.1 指针与地址

指针是能够存放一个地址的一组存储单元，通常是2个或4个字节。

一元运算符`&`可以取一个对象的地址，只能应用于变量和数组元素（内存中的对象）。不能用于表达式、常量、`register`类型的变量。

```c
p = &c; //把c的地址赋值给p，称p为“指向”c的指针
```

一元运算符`*`是间接寻址或间接引用运算符。

```c
int *ip; /* ip是指向int类型的指针 */
int x = 1, y = 2;
ip = &x;
y = *ip;  /* y现在是1 */
```

指针ip的声明如下所示，这样声明是为了便于记忆，该声明语句的声明表达式`*p`的结果是`int`类型

```c
int *ip; 
```

每个指针都必须指向某种特定的数据类型。除`void`类型的指针，可以存放指向任何类型的指针，但它不能间接引用其自身。

一元运算符`*`、`&`的优先级比算术运算符的优先级高，所以`y = *ip + 1`会把`ip`指向的对象的值取出来加1再赋值给`y`。

**一元运算符遵循从右至左的结合顺序**，所以`*p++`是对指针先加1再取值

## 5.2 指针与函数参数

`scanf`的设计：将标识是否到达文件结尾的状态作为函数的返回值，同时用指针参数存储接收到的值并传回给主调函数。

## 5.3 指针与数组

通过数组下标能完成的任何操作都可以通过指针来实现，一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。

指针加1意味着取指针所指的对象的下一个对象，C语言会根据指针的类型决定加1操作移动多少个字节。

数组名所代表的的就是该数组最开始的一个元素的地址。

在计算数组元素`a[i]`的值时，C语言实际上是先将其转换为了`*(a + i)`的形式。所以两种形式是等价的，指针也可以使用下标写法。

数组名和指针有一个不同之处：指针是一个变量，可以进行赋值；但数组名不是变量，不能进行赋值。

将数组名传递给函数时，实际上传递的是该数组第一个元素的地址。

字符串常量作为参数，传递的也是字符数组的第一个元素的地址。

在函数定义中`char s[]`和`char *s`是等价的，我们通常更习惯于使用后一种形式。

语法上是可以访问数组第一个元素之前的元素，编译器可能会warning，但是语法允许，不过这样做没什么意义。

## 5.4 地址算数运算

一般情况下，指针也可以初始化，有意义的初始化值只能是0或者其他表示地址的表达式。

C语言保证，0永远不是有效的数据地址。

指针与整数之间不能互相转换，但是0是惟一的例外：常量0可以赋值给指针，指针也可以和常量0进行比较。经常用符号常量`NULL`来代替常量0，这样便于更清晰地说明常量0是指针的一个特殊值。`NULL`定义在`<stddef.h>`里。

指针在某下情况下可以进行比较运算，如果两个指针指向同一个数组的成员。

任何指针与0进行相等和不等的比较运算都有意义，但是指向不同数组的元素的指针之间的算数或比较运算没有意义。

指针可以和整数进行相加或相减运算，无论指针指向的对象是何种类型，`p + n`都是表示指针p当前指向的对象之后第n个对象的地址。C语言会根据p指向的对象的长度按比例缩放

指针相减可以用来计算元素的个数

`size_t`由运算符`sizeof`返回的无符号整型，可以保证存下任何数组大小（可以存下除类的函数指针以外的任意指针）

有效的指针运算有：相同类型指针的赋值，指针和整数的加减法运算，指向相同数组中元素的两个指针间的减法或比较运算，指针赋值为0或指针与0之间的比较运算。

## 5.5 字符指针与函数

字符串常量是一个字符数组，作为函数参数时，实际上是通过字符指针访问该字符串的，函数接受的是一个指向字符数组的第一个字符的指针。

函数`strcpy`的更高级的写法

```c
void strcpy(char *s, char *t) {
  while ((*s++ = *t++) != '\0')
    ;
}
```

`*t++`的值是执行自增运算之前`t`所指向的字符，在读取该字符之后`++`才改变`t`的值。`s`也是同理，`*s++`的字符值同时也用来和空字符`\0`进行比较运算，来控制循环的执行。这部分比较其实也是多余的，可以写成：

```c
void strcpy(char *s, char *t) {
  while ((*s++ = *t++))
    ;
}
```

在标准库`<string.h>`里的`strcpy`函数是把目标字符串作为函数值返回的。

`strcmp(s, t)`的返回值是`s`和`t`由前向后逐字符比较时遇到的第一个不相等字符处的字符的差值。

进栈和出栈的标准用法：

```c
*p++ = val;
val = *--p;
```

## 5.6 指针数组以及指向指针的指针

```c
char *lineptr[MAXLINES];
```

声明了一个数组，内部存放的是`char`类型的指针

## 5.7 多维数组

```c
char daytab[2][13] = {
  {0, 31, 28, ...},
  {0, 31, 29, ...}
};

char a = daytab[2][2];
```

二维数组数组元素按行存储，可以用花括号初始化。

如果作为参数传递给函数，那么再参数声明中必须指明数组的列数，可以不写行数。调用的时候传递的是一个指针，指向由行向量构成的一位数组。

```c
f(int daytab[2][13]) {...}
f(int daytab[][13]) {...}
f(int (*daytab)[13]) {...}
```

以上三种写法等价，最后一种写法表明参数是一个指针，指向具有13个整型元素的一位数组

## 5.8 指针数组的初始化

与其他初始化类似

## 5.9 指针与多维数组

```c
int a[10][20];
int *b[10];
```

`a`是二维数组，`b`是指针数组，区别在于，`a`一次性分配了200个`int`的空间，而`b`一开始只分配了10个指针的空间，而且没有初始化，并且`b`的每一行长度可以不同。

## 5.10 命令行参数

在支持C语言的环境中，可以在程序开始执行时将命令行参数传递给程序，`main`函数有2个参数，第一个参数`argc`用于参数计数，表示命令行中传递了几个参数，第二个参数`argv`用于参数向量，是一个指向字符串数组的指针，每个字符串对应一个参数

安装C语言的约定，`argv[0]`的值是启动该程序的程序名，所以`argc`至少为1。例如

```shell
echo hello world
```

中，`argv`有3个值，分别为：`echo`，`hello`，`world`

处理的时候可以通过`--argc > 0`来控制参数的读取

UNIX系统中C语言程序有一个公共的约定：以负号开头的参数表示一个可选的标志或参数。

## 5.11 指向函数的指针

在C语言中，函数本身不是变量，但是可以定义指向函数的指针，这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等。

```c
int (*)comp (void*, void*);  //函数指针的定义

(*comp)(v[i], v[left]);      //函数指针的使用
```

`qsort`函数的实现中的一些细节：

`qsort`函数原型为`void qsort(void *lineptr[], int left, int right, int (*comp)(void *, void*)); `

接收参数`int (*comp)(void *, void*)`可以实现基于任意比较方式的排序

传递参数的时候，函数名和数组名一样，使用的时候前面不需要加上取地址运算符`&`。名字本身就是地址。

`qsort`此时可以处理任何数据类型，第一个参数`lineptr`是一个指针数组，存放待排序的元素，由于任何类型的指针都可以转换为`void *`类型，并且在将它转换回原来的类型时不会丢失信息，所以调用`qsort`函数的时候可以将参数强制转换为`void *`类型，比较函数`comp`的参数也是如此处理。强制转换部分代码：`(void **)lineptr`。这种转换通常不会影响到数据的实际表示，但是要确保编译器不报错。

`qsort`部分完整代码：

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAXLINES 5000    /* 待排序的最大行数 */
char *lineptr[MAXLINES]; /* 指向文本行的指针 */

int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);

void qsort(void *lineptr[], int left, int right,
           int (*comp)(void *, void *));
int numcmp(char *, char *);

int main(int argc, char const *argv[])
{
    int nlines;      /* 读入的输入行数 */
    int numeric = 0; /* 若进行数值排序，则numeric为1 */

    if (argc > 1 && strcmp(argv[1], "-n") == 0)
        numeric = 1;
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0)
    {
        qsort((void **)lineptr, 0, nlines - 1, (int (*)(void *, void *))(numeric ? numcmp : strcmp));
        writelines(lineptr, nlines);
        return 0;
    }
    else
    {
        printf("input too big to sort\n");
        return 1;
    }
}

void qsort(void *v[], int left, int right,
           int (*comp)(void *, void *))
{
    int i, last;
    void swap(void *v[], int, int);

    if (left >= right) /* 如果数组元素个数小于2，则不执行任何操作 */
        return;
    swap(v, left, (left + right) / 2);
    last = left;
    for (i = 0; i < right; i++)
        if ((*comp)(v[i], v[left]) < 0)
            swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last - 1, comp);
    qsort(v, last + 1, right, comp);
}

int numcmp(char *s1, char *s2)
{
    double v1, v2;
    v1 = atof(s1);
    v2 = atof(s2);
    if (v1 < v2)
        return -1;
    else if (v1 > v2)
        return 1;
    else
        return 0;
}

void swap(void *v[], int i, int j)
{
    void *temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```

## 5.12 复杂声明

`()`和`[]`的优先级大于`*`

复杂表达式的阅读：[“go right when you can, go left when you must”](http://unixwiz.net/techtips/reading-cdecl.html)，pointer to，array of，function returning

# 第六章 结构

结构是一个或多个变量的集合，这些变量类型可以不同。由于结构将一组相关的变量看作一个单元，因此有助于组织复杂的数据。

## 6.1 结构的基本知识

结构的声明：

```c
struct point {
	int x;
	int y;
};
```

`struct`后的名字`point`叫做*结构标记*，是可选的，用于为结构体命名，可以作为结构体声明的简写形式。

结构体内的变量称为*成员*。

结构成员、结构标记、普通变量可以使用相同的名字，不会冲突。

在结构声明的右花括号之后可以跟一个变量表，用来声明变量。

```c
struct { ... } x, y, z;

//从语法角度来说，与下面的声明有类似的意义，声明变量并分配空间（定义）
int x, y, z;
```

如果结构声明后不带变量表，那么只是声明。

如果声明时有结构标记，那么之后定义结构实例的时候就可以使用标记来定义，如

```c
struct point pt = { 320, 200 };
```

初始化也可以直接跟初值表。初值必须是常量表达式。

引用某个特定结构的成员：

```c
结构名.成员
```

## 6.2 结构与函数

结构的合法操作只有：

1. 作为一个整体复制和赋值
2. 通过`&`运算符取地址
3. 访问其成员

结构可以作为函数的参数和返回值，结构之间不可以比较。

```c
struct point addpoint(struct point p1, struct point p2)
{
  p1.x += p2.x;
  p1.y += p2.y;
  return p1;
}
```

注意结构作为函数参数传递时，也是值传递，传递了一个结构的副本。

传递指针的效率会更高，声明结构指针

```c
struct point *pp;
```

结构成员运算符`.`的优先级比`*`的优先级高，所以取结构指针的成员要写`(*pp).x`

C语言提供了另一种写法`pp->x`，`.`和`->`都是从左至右结合的

在所有运算符里，以下4个运算符的优先级最高：结构运算符`.`和`->`，用于函数调用的`()`以及用于下标的`[]`

## 6.3 结构数组

声明

```c
struct key {
  char *word;
  int count;
} keytab[NKEYS];
```

初始化：

```c
struct key {
  char *word;
  int count;
} keytab[] = {
  "auto", 0,
  "break", 0,
  ...
};
//更精确的做法是
struct key {
  char *word;
  int count;
} keytab[] = {
  { "auto", 0 },
  { "break", 0 },
  ...
};

```

如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省略。



数组长度的计算：可以在结尾加上一个空指针，循环遍历计数。

数组小tips：有时候第一个位置可以留空，让下标和实际意义相符，如存储月份的数组



`sizeof`编译时的一元运算符，返回值是一个无符号整数值，类型为`size_t`，可以返回指定对象或类型占用的存储空间的字节数

数组长度：`sizeof keytab / sizeof keytab[0]`

预处理器中的条件包含语句`#if`里面不能使用`sizeof`，因为预处理器不对类型名进行分析，但是预处理并不计算`#define`语句中的表达式，所以`#define`中可以使用`sizeof`

## 6.4 指向结构的指针

指针加法是非法的，而指针的减法是合法的，如果要拿到一个数组中的两个指针的中间元素的指针：

```c
mid = low + (high - low) / 2;
```

结构的长度并不等于各成员长度的和，因为不同的对象有不同的对齐要求。使用`sizeof`运算符可以返回正确的长度

当返回值比较复杂的时候容易找不到函数名，所以一般会采用下面的写法

```c
struct key *binsearch(char *word, struct key *tab, int n)
  
struct key *
binsearch(char *word, struct key *tab, int n)
```

## 6.5 自引用结构

一个包含自己实例的结构是非法的，但是可以有自己结构的指针。

## 6.6 表查找

## 6.7 类型定义（typedef）

C语言提供了一个称为`typedef`的功能，它用来建立新的数据类型名，例如

```c
typedef int Length;
```

别名位于类似于变量名的位置

`typedef`声明并没有创建一个新类型，它只是给已存在的类型增加了一个新的名称

功能类似于`#define`。由编译器解释，所以功能要比预处理器强，`size_t`就是用`typedef`重命名的，这样在不同的机器上只需要修改`typedef`就可以不用修改代码

## 6.8 联合

将多个变量保存在一个存储空间里

```c
union u_tag {
  int ival;
  float fval;
  char *sval;
} u;
```

一个变量合法地保存多种数据类型中的任意一种。

使用方式和结构一样。读取的类型必须是最近一次存入的类型，由程序员来负责跟踪当前联合内的类型。

实际上，联合就是一个结构，所有成员相对于基地址的偏移量都为0，结构空间要足够大，并且对齐方式适合于所有类型。

联合只能用其第一个成员类型的值进行初始化。

## 6.9 位字段

多用于嵌入式开发，存储空间很宝贵的情况，可以在以bit为单位划分变量。

```c
struct {
  unsigned int a1 : 1;
  unsigned int a2 : 1;
  unsigned int a3 : 1;
} flags;
```

冒号后的数字表示字段的宽度，用二进制的位数表示。

使用和结构相同。flags是一个变量，a1只占1个bit。

字段可以不命名，无名字段（只有一个冒号和宽度）起填充作用，特殊宽度0可以用来强制在下一个字边界尚对齐。

# 第七章 输入与输出

ANSI标准精确地定义了一些库函数，来实现输入/输出，字符串处理，存储管理和数学函数。

## 7.1 标准输入/输出

文本流由一系列行组成，每一行的结尾是一个换行符，标准库会将不是这种模式的系统自动转换，如在输入端将回车符和换页符都转换为换行符，输出端进行反向转换。

```c
int getchar(void);        //从标准输入（一般为键盘）中一次读取一个字符，返回下一个输入字符，若遇到文件尾，则返回EOF

```

`EOF`在头文件`<stdio.h>`中定义，其值一般为`-1`，但是应该使用`EOF`，这样才能保证程序同`EOF`的特定值无关。

```shell
	prog <infile #可以通过<进行输入重定向，<infile在argv中不可见
```

```c

int putchar(int);


printf也可以向标准输出设备上输出数据，交叉调用putchar和printf，将按照函数调用的先后顺序依次产生
  
  
  
  使用输入/输出库函数的每个源程序必须在引用这些函数之前写头文件
  #include <stdio.h>
  
  文件名用尖括号括起来，预处理器将在特定位置查找指定文件，如UNIX系统中，一般在/usr/include中
```

putchar getchar tolower这种函数一般都是宏

## 7.2 格式化输出——printf函数

```c
int printf(char *format, arg1, arg2, ...)
  返回打印的字符数
  转换说明：%开始，转换字符结束，在这之间可以依次有
  负号，左对齐
  数，最小宽度，空格填充
  小数点，将宽度和精度隔开
  数，精度：字符串的最大字符数，浮点数的小数点位数，整型的最少数字数，0填充
  字母h或l，h为short，l为long，hd和ld
  
  宽度或精度还可以用*表示，这时候宽度和精度的值通过下一个参数指定，必须为int
  printf("%.*s", max, s)
  
  
  
  sprintf(char *string, char *format, arg1, arg2, ...)
  和printf一样，按照format格式格式化参数序列，但是将输出结果存放到string中
```

## 7.3 变长参数表

```c
int printf(char *fmt, ...)
  省略号表示参数表中的参数的数量和类型是可变的，省略号只能出现在参数表的尾部
  
  在<stdarg.h>中包含一组宏定义，来遍历参数表
  va_list类型用于声明一个变量，依次引用参数
  va_start将参数指针初始化为指向第一个无名参数的指针，使用参数指针前必须调用一次
  参数表至少要包括一个有名参数，va_start将最后一个有名参数作为起点
  va_arg函数，每次调用返回一个参数，并将参数指针指向下一个参数，使用一个类型名来决定返回的对象类型、指针移动的步长
  va_end用来完成必要的清理操作
  
  va_list ap;  //ap是参数指针
va_start(ap, fmt);  //以最后一个有名参数为起点，使ap指向第一个无名参数
ival = va_arg(ap, int); 将参数取出存放在ival里，ap指向下一个参数
  sval = va_arg(ap, char *); 将参数取出存放在ival里，ap指向下一个参数
  va_end(ap);清理
  
```

## 7.4 格式化输入——scanf函数

```c
scanf对应于输入函数printf，从相反的方向上提供相同的转换功能
  
  int scanf(char *format, ...)
  从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余参数中，其他所有参数都必须是指针，用于指定经格式转换后的响应输入保存的位置
  
  扫描完格式串，或者遇到无法匹配的情况，函数终止
  返回值是成功匹配并赋值的个数
  到达文件尾，返回EOF
  0表示下一个输入的字符与格式串中第一个格式说明不匹配
  下一次调用scanf函数将从上一次转换的最后一个字符的下一个字符开始继续搜索
  
  
  int sscanf(char *string, char *format, arg1, arg2, ...)
  从一个字符串中读取字符序列
  
  格式串可能包含一列部分
  空格或制表符，在处理过程中将被忽略
  普通字符（不包括%），用于匹配输入流中的下一个非空白字符
  转换说明；
    依次由一个%，
  一个可选的赋值禁止字符*，  跳过该输入字段，不进行赋值
  一个可选的数值 指定最大字段宽度  
  一个可选的h、l或L字符（指定目标对象的宽度）以及一个转换字符组成
  
  
  输入字段是一个不包含空白符的字符串，边界定义为到下一个空白符或达到指定的字段宽度。所以读取的时候回跨过行边界
  
```

如果读取格式不固定的一对日期数据，可以用getline一次读一行，然后用sscanf去处理

## 7.5 文件访问

```c

<stdio.h>定义了文件指针FILE
  FILE *fp;
FILE *fopen(char *name, char* mode);
fopen的第一个参数是一个字符串，文件名；第二个参数是访问模式，也是一个字符串，有r w a 读写追加，有写系统还区分文本文件和二进制文件，后者在模式字符串里加b
  
  写或追加一个不存在的文件会创建该文件
  写的方式打开一个已存在的文件，原来的内容会被覆盖
  追加原来的内容将会被保留
  读一个不存在的文件会导致错误
  读取无权限的文件也会错误
  发生错误会返回NULL
  
int   getc(FILE *fp)
  返回下一个字符
  文件尾或出现错误，会返回EOF
  
  int putc(int c, FILE *fp);
将c写入，并返回写入的字符
  如果发生错误返回EOF
  这两个都是宏而不是函数
  
  
  
  启动一个C语言程序时，操作系统环境负责打开3个文件，标准输入、标准输出、标准错误
  stdin stdout stderr，大多数环境中，stdin 指向键盘，而stdout 和 stderr指向显示器
  
  文件的格式化输入和输出
int   fscanf(FILE *fp, char *format, ...)
  int fprintf(FILE *fp, char *format, ...)
  
  
  
  
  int fclose(FILE *fp)
  执行与fopen相反的操作，断开fopen函数简历的文件指针与外部名之间的连接，并释放文件指针以供其他文件使用
  
  
  大多数操作系统都限制了一个程序可以同时打开文件的树木，所以当文件指针不用的时候就应该释放
```

## 7.6 错误处理——stderr和exit

可以通过fprintf(stderr,...)将错误信息输出到标准错误上，一般是屏幕上

也可以使用exit函数

当该函数被调用时，它将终止调用函数的执行，并返回其中的参数`exit(0)，在main函数中，return expr等价于exit(expr)`不过exit还可以在其他函数中调用，感觉有点像throw Exception

```c
int ferror(FILE *fp)
  
  如果流fp中出现错误，则ferror返回一个非0值，如磁盘满了的时候可能会出现
  feof(FILE*)与ferror类似，当指定的文件到达文件尾，将返回一个非0的值
```

## 7.7 行输入和行输出

标准库提供了一个输入函数fgets

```c
char *fgets(char *line, int maxline, FILE *fp)
  fgets函数从fp指向的文件汇总读取下一个输入行（包括换行符，并将它存放在字符数组line中，最多可以读取maxline-1个字符。读取的行将以'\0'结尾保存在数组中
  
  
  如果遇到了文件尾或发生了错误则返回NULL
  
int   fputs(char *line, FILE *fp)
  将一个字符串写入到一个文件中
  发生错误将返回EOF，否则返回一个非负值
  
  
  gets和puts的功能与上面两个函数类似，但是是对stdin和stdout进行操作
  gets函数在读取字符串时将删除结尾的换行符
  puts在写入字符串时将在结尾添加一个换行符
  
  
```

## 7.8 其他函数

### 7.8.1 字符串操作函数

在下面各个函数中，s与t为`char *`类型，c与n为int类型

下面的函数都在头文件`<string.h>`中定义

```c
strcat(s,t);        将t指向的字符串连接到s指向的字符串的末尾
strncat(s,t,n);     将t指向的字符串的钱n个字符连接到s指向的字符串的末尾
strcmp(s,t);        s指向的字符串小于t指向的字符串返回负整数，相等返回0，大于返回正整数
strcmp(s,t,n);  只比较浅n个
strcpy(s,t); 将t指向的字符串复制到s指向的位置
strncpy(s,t,n)只复制前n个
strlen(s);返回s指向的字符串的长度
strchr(s,c)在s指向的字符串中查找c，找到返回第一次出现位置的指针，否则返回NULL
strrchr(s,c)在s指向的字符串中查找c，找到返回最后一次出现的位置的指针，否则返回NULL
```

### 7.8.2 字符类别测试和转换函数

<ctype.h> c是一个课表上为unsigned char类型或EOF的int对象，返回值类型为int，是返回一个非0只，否则返回0

```c
isalpha(c);是字母
isupper(c);大写字母
islower(c);小写字母
isdigit(c);数字
isalnum(c);字母或数字
isspace(c);空格、换行符、回车符、换页符、横向制表符、纵向制表符
toupper(c);返回c的大写形式
tolower(c);返回c的小写形式
```

### 7.8.3 ungetc函数

将字符c写回到文件fp中，执行成功返回c，否则返回EOF。每个文件还能接受一个写回字符

```c
int ungetc(int c, FILE *fp)
```



### 7.8.4 命令执行函数

执行s中的命令，然后继续执行当前程序，返回一个整型状态值，来自于s中的命令，与具体的系统有关

```c
system(char *s);
system("ls");
```



### 7.8.5 存储管理函数

动态分配存储块

```c

void *malloc(size_t n);
成功  返回一个指针，指向n字节长度的未初始化的存储空间，否则返回NULL
  void *calloc(size_t n, size_t size);
成功返回一个指针，指向足以容纳由n个指定长度的对象组成的数组，否则返回NULL，初始化为0
free(p);
释放p的存储空间，只能释放通过调用malloc或calloc函数得到的指针所指向的存储空间，释放别的或已释放的空间会产生错误
```



### 7.8.6 数学函数

<math.h>  每个函数带有一个或两个double类型的参数，并返回一个double类型的值

```c
sin(x);
cos(x);
atan2(y,x);
exp(x);
log(x);
log10(x);
pow(x);
sqrt(x);
fabs(x);

```



### 7.8.7 随机数发生器函数

rand()生成介于0和RAND_MAX之间的伪随机整数序列，RAND_MAX是在<stdlib.h>中定义的符号常量

```c
rand();
#define frand() ((double) rand() / (RAND_MAX+1.0))
生成大于等于0但小于1的随机浮点数
```

srand(unsigned)可以设置rand函数的种子数，如果用的函数库提供一个生成浮点随机数的函数，那应该会比上面这个有更好的统计学特性

# 第八章 UNIX系统接口

略